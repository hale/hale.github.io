---
slug: "cryptopals"
title: "Cryptopals Challenges"
---


<style type="text/css">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter a,
.syntaxhighlighter div,
.syntaxhighlighter code,
.syntaxhighlighter table,
.syntaxhighlighter table td,
.syntaxhighlighter table tr,
.syntaxhighlighter table tbody,
.syntaxhighlighter table thead,
.syntaxhighlighter table caption,
.syntaxhighlighter textarea {
  -moz-border-radius: 0 0 0 0 !important;
  -webkit-border-radius: 0 0 0 0 !important;
  background: none !important;
  border: 0 !important;
  bottom: auto !important;
  float: none !important;
  height: auto !important;
  left: auto !important;
  line-height: 1.1em !important;
/*  margin: 0 !important; */
  outline: 0 !important;
  overflow: visible !important;
  padding: 0 !important;
  position: static !important;
  right: auto !important;
  text-align: left !important;
  top: auto !important;
  vertical-align: baseline !important;
  width: auto !important;
  box-sizing: content-box !important;
  font-family: "Consolas", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace !important;
  font-weight: normal !important;
  font-style: normal !important;
  min-height: inherit !important;
  min-height: auto !important;
}

.syntaxhighlighter {
/*  width: 100% !important; */
  margin: 1em 0 1em 0 !important;
  position: relative !important;
  overflow: auto !important;
}
.syntaxhighlighter.source {
  overflow: hidden !important;
}
.syntaxhighlighter .bold {
  font-weight: bold !important;
}
.syntaxhighlighter .italic {
  font-style: italic !important;
}
.syntaxhighlighter .line {
  white-space: pre !important;
}
.syntaxhighlighter table {
/*    width: 100% !important;*/
}
.syntaxhighlighter table caption {
  text-align: left !important;
  padding: .5em 0 0.5em 1em !important;
}
.syntaxhighlighter table td.code {
  width: 100% !important;
}
.syntaxhighlighter table td.code .container {
  position: relative !important;
}
.syntaxhighlighter table td.code .container textarea {
  box-sizing: border-box !important;
  position: absolute !important;
  left: 0 !important;
  top: 0 !important;
  width: 100% !important;
  height: 100% !important;
  border: none !important;
  background: white !important;
  padding-left: 1em !important;
  overflow: hidden !important;
  white-space: pre !important;
}
.syntaxhighlighter table td.gutter .line {
  text-align: right !important;
  padding: 0 0.5em 0 1em !important;
}
.syntaxhighlighter table td.code .line {
  padding: 0 1em !important;
}
.syntaxhighlighter.nogutter td.code .container textarea, .syntaxhighlighter.nogutter td.code .line {
  padding-left: 0em !important;
}
.syntaxhighlighter.show {
  display: block !important;
}
.syntaxhighlighter.collapsed table {
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar {
    display: none;
/*  padding: 0.1em 0.8em 0em 0.8em !important;
  font-size: 1em !important;
  position: static !important;
  width: auto !important;
  height: auto !important;*/
}
.syntaxhighlighter.collapsed .toolbar span {
  display: inline !important;
  margin-right: 1em !important;
}
.syntaxhighlighter.collapsed .toolbar span a {
  padding: 0 !important;
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar span a.expandSource {
  display: inline !important;
}
.syntaxhighlighter .toolbar {
    display: none;
/*  position: absolute !important;
  right: 1px !important;
  top: 1px !important;
  width: 11px !important;
  height: 11px !important;
  font-size: 10px !important;
  z-index: 10 !important;*/
}
.syntaxhighlighter .toolbar span.title {
  display: inline !important;
}
.syntaxhighlighter .toolbar a {
  display: block !important;
  text-align: center !important;
  text-decoration: none !important;
  padding-top: 1px !important;
}
.syntaxhighlighter .toolbar a.expandSource {
  display: none !important;
}
.syntaxhighlighter.ie {
  font-size: .9em !important;
  padding: 1px 0 1px 0 !important;
}
.syntaxhighlighter.ie .toolbar {
  line-height: 8px !important;
}
.syntaxhighlighter.ie .toolbar a {
  padding-top: 0px !important;
}
.syntaxhighlighter.printing .line.alt1 .content,
.syntaxhighlighter.printing .line.alt2 .content,
.syntaxhighlighter.printing .line.highlighted .number,
.syntaxhighlighter.printing .line.highlighted.alt1 .content,
.syntaxhighlighter.printing .line.highlighted.alt2 .content {
  background: none !important;
}
.syntaxhighlighter.printing .line .number {
  color: #bbbbbb !important;
}
.syntaxhighlighter.printing .line .content {
  color: black !important;
}
.syntaxhighlighter.printing .toolbar {
  display: none !important;
}
.syntaxhighlighter.printing a {
  text-decoration: none !important;
}
.syntaxhighlighter.printing .plain, .syntaxhighlighter.printing .plain a {
  color: black !important;
}
.syntaxhighlighter.printing .comments, .syntaxhighlighter.printing .comments a {
  color: #008200 !important;
}
.syntaxhighlighter.printing .string, .syntaxhighlighter.printing .string a {
  color: blue !important;
}
.syntaxhighlighter.printing .keyword {
  color: #006699 !important;
  font-weight: bold !important;
}
.syntaxhighlighter.printing .preprocessor {
  color: gray !important;
}
.syntaxhighlighter.printing .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter.printing .value {
  color: #009900 !important;
}
.syntaxhighlighter.printing .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .constants {
  color: #0066cc !important;
}
.syntaxhighlighter.printing .script {
  font-weight: bold !important;
}
.syntaxhighlighter.printing .color1, .syntaxhighlighter.printing .color1 a {
  color: gray !important;
}
.syntaxhighlighter.printing .color2, .syntaxhighlighter.printing .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .color3, .syntaxhighlighter.printing .color3 a {
  color: red !important;
}
.syntaxhighlighter.printing .break, .syntaxhighlighter.printing .break a {
  color: black !important;
}
</style>



<style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style>

<style type="text/css">/**
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt1 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt2 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.highlighted.alt1, .syntaxhighlighter .line.highlighted.alt2 {
  background-color: #c3defe !important;
}
.syntaxhighlighter .line.highlighted.number {
  color: white !important;
}
.syntaxhighlighter table caption {
  color: black !important;
}
.syntaxhighlighter .gutter {
  color: #787878 !important;
}
.syntaxhighlighter .gutter .line {
  border-right: 3px solid #d4d0c8 !important;
}
.syntaxhighlighter .gutter .line.highlighted {
  background-color: #d4d0c8 !important;
  color: white !important;
}
.syntaxhighlighter.printing .line .content {
  border: none !important;
}
.syntaxhighlighter.collapsed {
  overflow: visible !important;
}
.syntaxhighlighter.collapsed .toolbar {
  color: #3f5fbf !important;
  background: white !important;
  border: 1px solid #d4d0c8 !important;
}
.syntaxhighlighter.collapsed .toolbar a {
  color: #3f5fbf !important;
}
.syntaxhighlighter.collapsed .toolbar a:hover {
  color: #aa7700 !important;
}
.syntaxhighlighter .toolbar {
  color: #a0a0a0 !important;
  background: #d4d0c8 !important;
  border: none !important;
}
.syntaxhighlighter .toolbar a {
  color: #a0a0a0 !important;
}
.syntaxhighlighter .toolbar a:hover {
  color: red !important;
}
.syntaxhighlighter .plain, .syntaxhighlighter .plain a {
  color: black !important;
}
.syntaxhighlighter .comments, .syntaxhighlighter .comments a {
  color: #3f5fbf !important;
}
.syntaxhighlighter .string, .syntaxhighlighter .string a {
  color: #2a00ff !important;
}
.syntaxhighlighter .keyword {
  color: #7f0055 !important;
}
.syntaxhighlighter .preprocessor {
  color: #646464 !important;
}
.syntaxhighlighter .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter .value {
  color: #009900 !important;
}
.syntaxhighlighter .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter .constants {
  color: #0066cc !important;
}
.syntaxhighlighter .script {
  font-weight: bold !important;
  color: #7f0055 !important;
  background-color: none !important;
}
.syntaxhighlighter .color1, .syntaxhighlighter .color1 a {
  color: gray !important;
}
.syntaxhighlighter .color2, .syntaxhighlighter .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter .color3, .syntaxhighlighter .color3 a {
  color: red !important;
}

.syntaxhighlighter .xml .keyword {
  color: #3f7f7f !important;
  font-weight: normal !important;
}
.syntaxhighlighter .xml .color1, .syntaxhighlighter .xml .color1 a {
  color: #7f007f !important;
}
.syntaxhighlighter .xml .string {
  font-style: italic !important;
  color: #2a00ff !important;
}

.clojure.syntaxhighlighter .invalid { 
   background-color: #FAA !important;
}

.clojure.syntaxhighlighter .quoted {      
    font-style: italic !important;
}

.syntaxhighlighter .clojure.variable,
.syntaxhighlighter .clojure.symbol,
.syntaxhighlighter .clojure.value
{
    color: #006060 !important;
}

.syntaxhighlighter .clojure.string {
    color: #55B !important;
}

.syntaxhighlighter .clojure.functions {
    color: black !important;
}

.syntaxhighlighter .clojure.color1 {
    color: #666 !important;
}

.syntaxhighlighter .clojure.color3 {
    color: #900 !important;
}

.syntaxhighlighter .clojure.constants {
    color: #1A734D !important;
}

</style>



<style type="text/css">html{margin:0;padding:0;}h1{margin:0;padding:0;}h2{margin:0;padding:0;}h3{margin:0;padding:0;}h4{margin:0;padding:0;}a{color:#261A3B;}a:visited{color:#261A3B;}</style>

<style type="text/css"> .header{margin-top:30px;}h1.project-name{font-size:34px;display:inline;}h2.project-version{font-size:18px;margin-top:0;display:inline;margin-left:10px;}.toc-link{font-size:12px;margin-left:10px;color:#252519;text-decoration:none;}.toc-link:hover{color:#5050A6;}.toc h1{font-size:34px;margin:0;}.docs-header{border-bottom:dotted #aaa 1px;padding-bottom:10px;margin-bottom:25px;}.toc h1{font-size:24px;}.toc{border-bottom:solid #bbb 1px;margin-bottom:40px;}.toc ul{margin-left:20px;padding-left:0px;padding-top:0;margin-top:0;}.toc li{list-style-type:none;padding-left:0;}.dependencies{}.dependencies table{font-size:16px;width:99.99%;border:none;margin-left:20px;}.dependencies td{padding-right:20px;;white-space:nowrap;}.dependencies .dotted{width:99%;}.dependencies .dotted hr{border-right:none;color:transparent;background-color:transparent;noshade:noshade;border-left:none;border-top:none;margin-bottom:-6px;height:0;border-bottom:dotted #bbb 1px;}.dependencies .dep-version{text-align:right;}.plugins ul{margin-left:20px;padding-left:0px;padding-top:0;margin-top:0;}.plugins li{list-style-type:none;padding-left:0;}.header p{margin-left:20px;} </style>

<style type="text/css">#floating-toc{position:fixed;top:10px;right:20px;height:20px;overflow:hidden;text-align:right;}#floating-toc li{list-style-type:none;margin:0;padding:0;}</style><style type="text/css">body{margin:0;padding:0;font-family:'Palatino Linotype', 'Book Antiqua', Palatino, FreeSerif, serif;;font-size:16px;color:#252519;background-color:#F5F5FF;}h1{font-size:20px;margin-top:0;}h2{font-size:18px;}h3{font-size:16px;}a.anchor{text-decoration:none;color:#252519;}a.anchor:hover{color:#5050A6;}table{border-spacing:0;border-bottom:solid #ddd 1px;;margin-bottom:10px;}code{display:inline;}p{margin-top:8px;}tr{margin:0px;padding:0px;}td.docs{width:410px;max-width:410px;vertical-align:top;margin:0px;padding-left:55px;padding-right:20px;border:none;background-color:#FFF;}td.docs pre{font-size:12px;overflow:hidden;}td.codes{vertical-align:top;font-size:10pt;overflow:hidden;background-color:#F5F5FF;width:55%;border-left:solid #E5E5EE 1px;padding-left:20px;border:none;margin:0px;}td.spacer{padding-bottom:40px;}pre code{display:block;padding:4px;}code{background-color:ghostWhite;border:solid #DEDEDE 1px;padding-left:3px;padding-right:3px;font-size:14px;}.syntaxhighlighter code{font-size:13px;}.footer{text-align:center;}</style>


<script type="text/javascript">//XRegExp 1.5.0 <xregexp.com> MIT License
var XRegExp;if(XRegExp){throw Error("can't load XRegExp twice in the same frame")}(function(){XRegExp=function(w,r){var q=[],u=XRegExp.OUTSIDE_CLASS,x=0,p,s,v,t,y;if(XRegExp.isRegExp(w)){if(r!==undefined){throw TypeError("can't supply flags when constructing one RegExp from another")}return j(w)}if(g){throw Error("can't call the XRegExp constructor within token definition functions")}r=r||"";p={hasNamedCapture:false,captureNames:[],hasFlag:function(z){return r.indexOf(z)>-1},setFlag:function(z){r+=z}};while(x<w.length){s=o(w,x,u,p);if(s){q.push(s.output);x+=(s.match[0].length||1)}else{if(v=m.exec.call(i[u],w.slice(x))){q.push(v[0]);x+=v[0].length}else{t=w.charAt(x);if(t==="["){u=XRegExp.INSIDE_CLASS}else{if(t==="]"){u=XRegExp.OUTSIDE_CLASS}}q.push(t);x++}}}y=RegExp(q.join(""),m.replace.call(r,h,""));y._xregexp={source:w,captureNames:p.hasNamedCapture?p.captureNames:null};return y};XRegExp.version="1.5.0";XRegExp.INSIDE_CLASS=1;XRegExp.OUTSIDE_CLASS=2;var c=/\$(?:(\d\d?|[$&`'])|{([$\w]+)})/g,h=/[^gimy]+|([\s\S])(?=[\s\S]*\1)/g,n=/^(?:[?*+]|{\d+(?:,\d*)?})\??/,g=false,k=[],m={exec:RegExp.prototype.exec,test:RegExp.prototype.test,match:String.prototype.match,replace:String.prototype.replace,split:String.prototype.split},a=m.exec.call(/()??/,"")[1]===undefined,e=function(){var p=/^/g;m.test.call(p,"");return !p.lastIndex}(),f=function(){var p=/x/g;m.replace.call("x",p,"");return !p.lastIndex}(),b=RegExp.prototype.sticky!==undefined,i={};i[XRegExp.INSIDE_CLASS]=/^(?:\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S]))/;i[XRegExp.OUTSIDE_CLASS]=/^(?:\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S])|\(\?[:=!]|[?*+]\?|{\d+(?:,\d*)?}\??)/;XRegExp.addToken=function(s,r,q,p){k.push({pattern:j(s,"g"+(b?"y":"")),handler:r,scope:q||XRegExp.OUTSIDE_CLASS,trigger:p||null})};XRegExp.cache=function(r,p){var q=r+"/"+(p||"");return XRegExp.cache[q]||(XRegExp.cache[q]=XRegExp(r,p))};XRegExp.copyAsGlobal=function(p){return j(p,"g")};XRegExp.escape=function(p){return p.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&")};XRegExp.execAt=function(s,r,t,q){r=j(r,"g"+((q&&b)?"y":""));r.lastIndex=t=t||0;var p=r.exec(s);if(q){return(p&&p.index===t)?p:null}else{return p}};XRegExp.freezeTokens=function(){XRegExp.addToken=function(){throw Error("can't run addToken after freezeTokens")}};XRegExp.isRegExp=function(p){return Object.prototype.toString.call(p)==="[object RegExp]"};XRegExp.iterate=function(u,p,v,s){var t=j(p,"g"),r=-1,q;while(q=t.exec(u)){v.call(s,q,++r,u,t);if(t.lastIndex===q.index){t.lastIndex++}}if(p.global){p.lastIndex=0}};XRegExp.matchChain=function(q,p){return function r(s,x){var v=p[x].regex?p[x]:{regex:p[x]},u=j(v.regex,"g"),w=[],t;for(t=0;t<s.length;t++){XRegExp.iterate(s[t],u,function(y){w.push(v.backref?(y[v.backref]||""):y[0])})}return((x===p.length-1)||!w.length)?w:r(w,x+1)}([q],0)};RegExp.prototype.apply=function(q,p){return this.exec(p[0])};RegExp.prototype.call=function(p,q){return this.exec(q)};RegExp.prototype.exec=function(t){var r=m.exec.apply(this,arguments),q,p;if(r){if(!a&&r.length>1&&l(r,"")>-1){p=RegExp(this.source,m.replace.call(d(this),"g",""));m.replace.call(t.slice(r.index),p,function(){for(var u=1;u<arguments.length-2;u++){if(arguments[u]===undefined){r[u]=undefined}}})}if(this._xregexp&&this._xregexp.captureNames){for(var s=1;s<r.length;s++){q=this._xregexp.captureNames[s-1];if(q){r[q]=r[s]}}}if(!e&&this.global&&!r[0].length&&(this.lastIndex>r.index)){this.lastIndex--}}return r};if(!e){RegExp.prototype.test=function(q){var p=m.exec.call(this,q);if(p&&this.global&&!p[0].length&&(this.lastIndex>p.index)){this.lastIndex--}return !!p}}String.prototype.match=function(q){if(!XRegExp.isRegExp(q)){q=RegExp(q)}if(q.global){var p=m.match.apply(this,arguments);q.lastIndex=0;return p}return q.exec(this)};String.prototype.replace=function(r,s){var t=XRegExp.isRegExp(r),q,p,u;if(t&&typeof s.valueOf()==="string"&&s.indexOf("${")===-1&&f){return m.replace.apply(this,arguments)}if(!t){r=r+""}else{if(r._xregexp){q=r._xregexp.captureNames}}if(typeof s==="function"){p=m.replace.call(this,r,function(){if(q){arguments[0]=new String(arguments[0]);for(var v=0;v<q.length;v++){if(q[v]){arguments[0][q[v]]=arguments[v+1]}}}if(t&&r.global){r.lastIndex=arguments[arguments.length-2]+arguments[0].length}return s.apply(null,arguments)})}else{u=this+"";p=m.replace.call(u,r,function(){var v=arguments;return m.replace.call(s,c,function(x,w,A){if(w){switch(w){case"$":return"$";case"&":return v[0];case"`":return v[v.length-1].slice(0,v[v.length-2]);case"'":return v[v.length-1].slice(v[v.length-2]+v[0].length);default:var y="";w=+w;if(!w){return x}while(w>v.length-3){y=String.prototype.slice.call(w,-1)+y;w=Math.floor(w/10)}return(w?v[w]||"":"$")+y}}else{var z=+A;if(z<=v.length-3){return v[z]}z=q?l(q,A):-1;return z>-1?v[z+1]:x}})})}if(t&&r.global){r.lastIndex=0}return p};String.prototype.split=function(u,p){if(!XRegExp.isRegExp(u)){return m.split.apply(this,arguments)}var w=this+"",r=[],v=0,t,q;if(p===undefined||+p<0){p=Infinity}else{p=Math.floor(+p);if(!p){return[]}}u=XRegExp.copyAsGlobal(u);while(t=u.exec(w)){if(u.lastIndex>v){r.push(w.slice(v,t.index));if(t.length>1&&t.index<w.length){Array.prototype.push.apply(r,t.slice(1))}q=t[0].length;v=u.lastIndex;if(r.length>=p){break}}if(u.lastIndex===t.index){u.lastIndex++}}if(v===w.length){if(!m.test.call(u,"")||q){r.push("")}}else{r.push(w.slice(v))}return r.length>p?r.slice(0,p):r};function j(r,q){if(!XRegExp.isRegExp(r)){throw TypeError("type RegExp expected")}var p=r._xregexp;r=XRegExp(r.source,d(r)+(q||""));if(p){r._xregexp={source:p.source,captureNames:p.captureNames?p.captureNames.slice(0):null}}return r}function d(p){return(p.global?"g":"")+(p.ignoreCase?"i":"")+(p.multiline?"m":"")+(p.extended?"x":"")+(p.sticky?"y":"")}function o(v,u,w,p){var r=k.length,y,s,x;g=true;try{while(r--){x=k[r];if((w&x.scope)&&(!x.trigger||x.trigger.call(p))){x.pattern.lastIndex=u;s=x.pattern.exec(v);if(s&&s.index===u){y={output:x.handler.call(p,s,w),match:s};break}}}}catch(q){throw q}finally{g=false}return y}function l(s,q,r){if(Array.prototype.indexOf){return s.indexOf(q,r)}for(var p=r||0;p<s.length;p++){if(s[p]===q){return p}}return -1}XRegExp.addToken(/\(\?#[^)]*\)/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"});XRegExp.addToken(/\((?!\?)/,function(){this.captureNames.push(null);return"("});XRegExp.addToken(/\(\?<([$\w]+)>/,function(p){this.captureNames.push(p[1]);this.hasNamedCapture=true;return"("});XRegExp.addToken(/\\k<([\w$]+)>/,function(q){var p=l(this.captureNames,q[1]);return p>-1?"\\"+(p+1)+(isNaN(q.input.charAt(q.index+q[0].length))?"":"(?:)"):q[0]});XRegExp.addToken(/\[\^?]/,function(p){return p[0]==="[]"?"\\b\\B":"[\\s\\S]"});XRegExp.addToken(/^\(\?([imsx]+)\)/,function(p){this.setFlag(p[1]);return""});XRegExp.addToken(/(?:\s+|#.*)+/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("x")});XRegExp.addToken(/\./,function(){return"[\\s\\S]"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("s")})})();
</script>

<script type="text/javascript">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
//
// Begin anonymous function. This is used to contain local scope variables without polutting global scope.
//
var SyntaxHighlighter = function() { 

// CommonJS
if (typeof(require) != 'undefined' && typeof(XRegExp) == 'undefined')
{
	XRegExp = require('XRegExp').XRegExp;
}

// Shortcut object which will be assigned to the SyntaxHighlighter variable.
// This is a shorthand for local reference in order to avoid long namespace 
// references to SyntaxHighlighter.whatever...
var sh = {
	defaults : {
		/** Additional CSS class names to be added to highlighter elements. */
		'class-name' : '',
		
		/** First line number. */
		'first-line' : 1,
		
		/**
		 * Pads line numbers. Possible values are:
		 *
		 *   false - don't pad line numbers.
		 *   true  - automaticaly pad numbers with minimum required number of leading zeroes.
		 *   [int] - length up to which pad line numbers.
		 */
		'pad-line-numbers' : false,
		
		/** Lines to highlight. */
		'highlight' : null,
		
		/** Title to be displayed above the code block. */
		'title' : null,
		
		/** Enables or disables smart tabs. */
		'smart-tabs' : true,
		
		/** Gets or sets tab size. */
		'tab-size' : 4,
		
		/** Enables or disables gutter. */
		'gutter' : true,
		
		/** Enables or disables toolbar. */
		'toolbar' : true,
		
		/** Enables quick code copy and paste from double click. */
		'quick-code' : true,
		
		/** Forces code view to be collapsed. */
		'collapse' : false,
		
		/** Enables or disables automatic links. */
		'auto-links' : true,
		
		/** Gets or sets light mode. Equavalent to turning off gutter and toolbar. */
		'light' : false,
		
		'html-script' : false
	},
	
	config : {
		space : '&nbsp;',
		
		/** Enables use of <SCRIPT type="syntaxhighlighter" /> tags. */
		useScriptTags : true,
		
		/** Blogger mode flag. */
		bloggerMode : false,
		
		stripBrs : false,
		
		/** Name of the tag that SyntaxHighlighter will automatically look for. */
		tagName : 'pre',
		
		strings : {
			expandSource : 'expand source',
			help : '?',
			alert: 'SyntaxHighlighter\n\n',
			noBrush : 'Can\'t find brush for: ',
			brushNotHtmlScript : 'Brush wasn\'t configured for html-script option: ',
			
			// this is populated by the build script
			aboutDialog : 'test'
		}
	},
	
	/** Internal 'global' variables. */
	vars : {
		discoveredBrushes : null,
		highlighters : {}
	},
	
	/** This object is populated by user included external brush files. */
	brushes : {},

	/** Common regular expressions. */
	regexLib : {
		multiLineCComments			: /\/\*[\s\S]*?\*\//gm,
		singleLineCComments			: /\/\/.*$/gm,
		singleLinePerlComments		: /#.*$/gm,
		doubleQuotedString			: /"([^\\"\n]|\\.)*"/g,
		singleQuotedString			: /'([^\\'\n]|\\.)*'/g,
		multiLineDoubleQuotedString	: new XRegExp('"([^\\\\"]|\\\\.)*"', 'gs'),
		multiLineSingleQuotedString	: new XRegExp("'([^\\\\']|\\\\.)*'", 'gs'),
		xmlComments					: /(&lt;|<)!--[\s\S]*?--(&gt;|>)/gm,
		url							: /\w+:\/\/[\w-.\/?%&=:@;]*/g,
		
		/** <?= ?> tags. */
		phpScriptTags 				: { left: /(&lt;|<)\?=?/g, right: /\?(&gt;|>)/g },
		
		/** <%= %> tags. */
		aspScriptTags				: { left: /(&lt;|<)%=?/g, right: /%(&gt;|>)/g },
		
		scriptScriptTags			: { left: /(&lt;|<)\s*script.*?(&gt;|>)/gi, right: /(&lt;|<)\/\s*script\s*(&gt;|>)/gi }
	},

	toolbar: {
		/**
		 * Generates HTML markup for the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @return {String} Returns HTML markup.
		 */
		getHtml: function(highlighter)
		{
			var html = '<div class="toolbar">',
				items = sh.toolbar.items,
				list = items.list
				;
			
			function defaultGetHtml(highlighter, name)
			{
				return sh.toolbar.getButtonHtml(highlighter, name, sh.config.strings[name]);
			};
			
			for (var i = 0; i < list.length; i++)
				html += (items[list[i]].getHtml || defaultGetHtml)(highlighter, list[i]);
			
			html += '</div>';
			
			return html;
		},
		
		/**
		 * Generates HTML markup for a regular button in the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @param {String} commandName		Command name that would be executed.
		 * @param {String} label			Label text to display.
		 * @return {String}					Returns HTML markup.
		 */
		getButtonHtml: function(highlighter, commandName, label)
		{
			return '<span><a href="#" class="toolbar_item'
				+ ' command_' + commandName
				+ ' ' + commandName
				+ '">' + label + '</a></span>'
				;
		},
		
		/**
		 * Event handler for a toolbar anchor.
		 */
		handler: function(e)
		{
			var target = e.target,
				className = target.className || ''
				;

			function getValue(name)
			{
				var r = new RegExp(name + '_(\\w+)'),
					match = r.exec(className)
					;

				return match ? match[1] : null;
			};
			
			var highlighter = getHighlighterById(findParentElement(target, '.syntaxhighlighter').id),
				commandName = getValue('command')
				;
			
			// execute the toolbar command
			if (highlighter && commandName)
				sh.toolbar.items[commandName].execute(highlighter);

			// disable default A click behaviour
			e.preventDefault();
		},
		
		/** Collection of toolbar items. */
		items : {
			// Ordered lis of items in the toolbar. Can't expect `for (var n in items)` to be consistent.
			list: ['expandSource', 'help'],

			expandSource: {
				getHtml: function(highlighter)
				{
					if (highlighter.getParam('collapse') != true)
						return '';
						
					var title = highlighter.getParam('title');
					return sh.toolbar.getButtonHtml(highlighter, 'expandSource', title ? title : sh.config.strings.expandSource);
				},
			
				execute: function(highlighter)
				{
					var div = getHighlighterDivById(highlighter.id);
					removeClass(div, 'collapsed');
				}
			},

			/** Command to display the about dialog window. */
			help: {
				execute: function(highlighter)
				{	
					var wnd = popup('', '_blank', 500, 250, 'scrollbars=0'),
						doc = wnd.document
						;
					
					doc.write(sh.config.strings.aboutDialog);
					doc.close();
					wnd.focus();
				}
			}
		}
	},

	/**
	 * Finds all elements on the page which should be processes by SyntaxHighlighter.
	 *
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are returned which qualify.
	 *
	 * @return {Array}	Returns list of <code>{ target: DOMElement, params: Object }</code> objects.
	 */
	findElements: function(globalParams, element)
	{
		var elements = element ? [element] : toArray(document.getElementsByTagName(sh.config.tagName)), 
			conf = sh.config,
			result = []
			;

		// support for <SCRIPT TYPE="syntaxhighlighter" /> feature
		if (conf.useScriptTags)
			elements = elements.concat(getSyntaxHighlighterScriptTags());

		if (elements.length === 0) 
			return result;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var item = {
				target: elements[i], 
				// local params take precedence over globals
				params: merge(globalParams, parseParams(elements[i].className))
			};

			if (item.params['brush'] == null)
				continue;
				
			result.push(item);
		}
		
		return result;
	},

	/**
	 * Shorthand to highlight all elements on the page that are marked as 
	 * SyntaxHighlighter source code.
	 * 
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are highlighted.
	 */ 
	highlight: function(globalParams, element)
	{
		var elements = this.findElements(globalParams, element),
			propertyName = 'innerHTML', 
			highlighter = null,
			conf = sh.config
			;

		if (elements.length === 0) 
			return;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var element = elements[i],
				target = element.target,
				params = element.params,
				brushName = params.brush,
				code
				;

			if (brushName == null)
				continue;

			// Instantiate a brush
			if (params['html-script'] == 'true' || sh.defaults['html-script'] == true) 
			{
				highlighter = new sh.HtmlScript(brushName);
				brushName = 'htmlscript';
			}
			else
			{
				var brush = findBrush(brushName);
				
				if (brush)
					highlighter = new brush();
				else
					continue;
			}
			
			code = target[propertyName];
			
			// remove CDATA from <SCRIPT/> tags if it's present
			if (conf.useScriptTags)
				code = stripCData(code);
				
			// Inject title if the attribute is present
			if ((target.title || '') != '')
				params.title = target.title;
				
			params['brush'] = brushName;
			highlighter.init(params);
			element = highlighter.getDiv(code);
			
			// carry over ID
			if ((target.id || '') != '')
				element.id = target.id;
			
			target.parentNode.replaceChild(element, target);
		}
	},

	/**
	 * Main entry point for the SyntaxHighlighter.
	 * @param {Object} params Optional params to apply to all highlighted elements.
	 */
	all: function(params)
	{
		attachEvent(
			window,
			'load',
			function() { sh.highlight(params); }
		);
	}
}; // end of sh

sh['all']			= sh.all;
sh['highlight']		= sh.highlight;

/**
 * Checks if target DOM elements has specified CSS class.
 * @param {DOMElement} target Target DOM element to check.
 * @param {String} className Name of the CSS class to check for.
 * @return {Boolean} Returns true if class name is present, false otherwise.
 */
function hasClass(target, className)
{
	return target.className.indexOf(className) != -1;
};

/**
 * Adds CSS class name to the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className New CSS class to add.
 */
function addClass(target, className)
{
	if (!hasClass(target, className))
		target.className += ' ' + className;
};

/**
 * Removes CSS class name from the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className CSS class to remove.
 */
function removeClass(target, className)
{
	target.className = target.className.replace(className, '');
};

/**
 * Converts the source to array object. Mostly used for function arguments and 
 * lists returned by getElementsByTagName() which aren't Array objects.
 * @param {List} source Source list.
 * @return {Array} Returns array.
 */
function toArray(source)
{
	var result = [];
	
	for (var i = 0; i < source.length; i++) 
		result.push(source[i]);
		
	return result;
};

/**
 * Splits block of text into lines.
 * @param {String} block Block of text.
 * @return {Array} Returns array of lines.
 */
function splitLines(block)
{
	return block.split('\n');
}

/**
 * Generates HTML ID for the highlighter.
 * @param {String} highlighterId Highlighter ID.
 * @return {String} Returns HTML ID.
 */
function getHighlighterId(id)
{
	var prefix = 'highlighter_';
	return id.indexOf(prefix) == 0 ? id : prefix + id;
};

/**
 * Finds Highlighter instance by ID.
 * @param {String} highlighterId Highlighter ID.
 * @return {Highlighter} Returns instance of the highlighter.
 */
function getHighlighterById(id)
{
	return sh.vars.highlighters[getHighlighterId(id)];
};

/**
 * Finds highlighter's DIV container.
 * @param {String} highlighterId Highlighter ID.
 * @return {Element} Returns highlighter's DIV element.
 */
function getHighlighterDivById(id)
{
	return document.getElementById(getHighlighterId(id));
};

/**
 * Stores highlighter so that getHighlighterById() can do its thing. Each
 * highlighter must call this method to preserve itself.
 * @param {Highilghter} highlighter Highlighter instance.
 */
function storeHighlighter(highlighter)
{
	sh.vars.highlighters[getHighlighterId(highlighter.id)] = highlighter;
};

/**
 * Looks for a child or parent node which has specified classname.
 * Equivalent to jQuery's $(container).find(".className")
 * @param {Element} target Target element.
 * @param {String} search Class name or node name to look for.
 * @param {Boolean} reverse If set to true, will go up the node tree instead of down.
 * @return {Element} Returns found child or parent element on null.
 */
function findElement(target, search, reverse /* optional */)
{
	if (target == null)
		return null;
		
	var nodes			= reverse != true ? target.childNodes : [ target.parentNode ],
		propertyToFind	= { '#' : 'id', '.' : 'className' }[search.substr(0, 1)] || 'nodeName',
		expectedValue,
		found
		;

	expectedValue = propertyToFind != 'nodeName'
		? search.substr(1)
		: search.toUpperCase()
		;
		
	// main return of the found node
	if ((target[propertyToFind] || '').indexOf(expectedValue) != -1)
		return target;
	
	for (var i = 0; nodes && i < nodes.length && found == null; i++)
		found = findElement(nodes[i], search, reverse);
	
	return found;
};

/**
 * Looks for a parent node which has specified classname.
 * This is an alias to <code>findElement(container, className, true)</code>.
 * @param {Element} target Target element.
 * @param {String} className Class name to look for.
 * @return {Element} Returns found parent element on null.
 */
function findParentElement(target, className)
{
	return findElement(target, className, true);
};

/**
 * Finds an index of element in the array.
 * @ignore
 * @param {Object} searchElement
 * @param {Number} fromIndex
 * @return {Number} Returns index of element if found; -1 otherwise.
 */
function indexOf(array, searchElement, fromIndex)
{
	fromIndex = Math.max(fromIndex || 0, 0);

	for (var i = fromIndex; i < array.length; i++)
		if(array[i] == searchElement)
			return i;
	
	return -1;
};

/**
 * Generates a unique element ID.
 */
function guid(prefix)
{
	return (prefix || '') + Math.round(Math.random() * 1000000).toString();
};

/**
 * Merges two objects. Values from obj2 override values in obj1.
 * Function is NOT recursive and works only for one dimensional objects.
 * @param {Object} obj1 First object.
 * @param {Object} obj2 Second object.
 * @return {Object} Returns combination of both objects.
 */
function merge(obj1, obj2)
{
	var result = {}, name;

	for (name in obj1) 
		result[name] = obj1[name];
	
	for (name in obj2) 
		result[name] = obj2[name];
		
	return result;
};

/**
 * Attempts to convert string to boolean.
 * @param {String} value Input string.
 * @return {Boolean} Returns true if input was "true", false if input was "false" and value otherwise.
 */
function toBoolean(value)
{
	var result = { "true" : true, "false" : false }[value];
	return result == null ? value : result;
};

/**
 * Opens up a centered popup window.
 * @param {String} url		URL to open in the window.
 * @param {String} name		Popup name.
 * @param {int} width		Popup width.
 * @param {int} height		Popup height.
 * @param {String} options	window.open() options.
 * @return {Window}			Returns window instance.
 */
function popup(url, name, width, height, options)
{
	var x = (screen.width - width) / 2,
		y = (screen.height - height) / 2
		;
		
	options +=	', left=' + x + 
				', top=' + y +
				', width=' + width +
				', height=' + height
		;
	options = options.replace(/^,/, '');

	var win = window.open(url, name, options);
	win.focus();
	return win;
};

/**
 * Adds event handler to the target object.
 * @param {Object} obj		Target object.
 * @param {String} type		Name of the event.
 * @param {Function} func	Handling function.
 */
function attachEvent(obj, type, func, scope)
{
	function handler(e)
	{
		e = e || window.event;
		
		if (!e.target)
		{
			e.target = e.srcElement;
			e.preventDefault = function()
			{
				this.returnValue = false;
			};
		}
			
		func.call(scope || window, e);
	};
	
	if (obj.attachEvent) 
	{
		obj.attachEvent('on' + type, handler);
	}
	else 
	{
		obj.addEventListener(type, handler, false);
	}
};

/**
 * Displays an alert.
 * @param {String} str String to display.
 */
function alert(str)
{
	window.alert(sh.config.strings.alert + str);
};

/**
 * Finds a brush by its alias.
 *
 * @param {String} alias		Brush alias.
 * @param {Boolean} showAlert	Suppresses the alert if false.
 * @return {Brush}				Returns bursh constructor if found, null otherwise.
 */
function findBrush(alias, showAlert)
{
	var brushes = sh.vars.discoveredBrushes,
		result = null
		;
	
	if (brushes == null) 
	{
		brushes = {};
		
		// Find all brushes
		for (var brush in sh.brushes) 
		{
			var info = sh.brushes[brush],
				aliases = info.aliases
				;
			
			if (aliases == null) 
				continue;
			
			// keep the brush name
			info.brushName = brush.toLowerCase();
			
			for (var i = 0; i < aliases.length; i++) 
				brushes[aliases[i]] = brush;
		}
		
		sh.vars.discoveredBrushes = brushes;
	}
	
	result = sh.brushes[brushes[alias]];

	if (result == null && showAlert != false)
		alert(sh.config.strings.noBrush + alias);
	
	return result;
};

/**
 * Executes a callback on each line and replaces each line with result from the callback.
 * @param {Object} str			Input string.
 * @param {Object} callback		Callback function taking one string argument and returning a string.
 */
function eachLine(str, callback)
{
	var lines = splitLines(str);
	
	for (var i = 0; i < lines.length; i++)
		lines[i] = callback(lines[i], i);
		
	return lines.join('\n');
};

/**
 * This is a special trim which only removes first and last empty lines
 * and doesn't affect valid leading space on the first line.
 * 
 * @param {String} str   Input string
 * @return {String}      Returns string without empty first and last lines.
 */
function trimFirstAndLastLines(str)
{
	return str.replace(/^[ ]*[\n]+|[\n]*[ ]*$/g, '');
};

/**
 * Parses key/value pairs into hash object.
 * 
 * Understands the following formats:
 * - name: word;
 * - name: [word, word];
 * - name: "string";
 * - name: 'string';
 * 
 * For example:
 *   name1: value; name2: [value, value]; name3: 'value'
 *   
 * @param {String} str    Input string.
 * @return {Object}       Returns deserialized object.
 */
function parseParams(str)
{
	var match, 
		result = {},
		arrayRegex = new XRegExp("^\\[(?<values>(.*?))\\]$"),
		regex = new XRegExp(
			"(?<name>[\\w-]+)" +
			"\\s*:\\s*" +
			"(?<value>" +
				"[\\w-%#]+|" +		// word
				"\\[.*?\\]|" +		// [] array
				'".*?"|' +			// "" string
				"'.*?'" +			// '' string
			")\\s*;?",
			"g"
		)
		;

	while ((match = regex.exec(str)) != null) 
	{
		var value = match.value
			.replace(/^['"]|['"]$/g, '') // strip quotes from end of strings
			;
		
		// try to parse array value
		if (value != null && arrayRegex.test(value))
		{
			var m = arrayRegex.exec(value);
			value = m.values.length > 0 ? m.values.split(/\s*,\s*/) : [];
		}
		
		result[match.name] = value;
	}
	
	return result;
};

/**
 * Wraps each line of the string into <code/> tag with given style applied to it.
 * 
 * @param {String} str   Input string.
 * @param {String} css   Style name to apply to the string.
 * @return {String}      Returns input string with each line surrounded by <span/> tag.
 */
function wrapLinesWithCode(str, css)
{
	if (str == null || str.length == 0 || str == '\n') 
		return str;

	str = str.replace(/</g, '&lt;');

	// Replace two or more sequential spaces with &nbsp; leaving last space untouched.
	str = str.replace(/ {2,}/g, function(m)
	{
		var spaces = '';
		
		for (var i = 0; i < m.length - 1; i++)
			spaces += sh.config.space;
		
		return spaces + ' ';
	});

	// Split each line and apply <span class="...">...</span> to them so that
	// leading spaces aren't included.
	if (css != null) 
		str = eachLine(str, function(line)
		{
			if (line.length == 0) 
				return '';
			
			var spaces = '';
			
			line = line.replace(/^(&nbsp;| )+/, function(s)
			{
				spaces = s;
				return '';
			});
			
			if (line.length == 0) 
				return spaces;
			
			return spaces + '<code class="' + css + '">' + line + '</code>';
		});

	return str;
};

/**
 * Pads number with zeros until it's length is the same as given length.
 * 
 * @param {Number} number	Number to pad.
 * @param {Number} length	Max string length with.
 * @return {String}			Returns a string padded with proper amount of '0'.
 */
function padNumber(number, length)
{
	var result = number.toString();
	
	while (result.length < length)
		result = '0' + result;
	
	return result;
};

/**
 * Replaces tabs with spaces.
 * 
 * @param {String} code		Source code.
 * @param {Number} tabSize	Size of the tab.
 * @return {String}			Returns code with all tabs replaces by spaces.
 */
function processTabs(code, tabSize)
{
	var tab = '';
	
	for (var i = 0; i < tabSize; i++)
		tab += ' ';

	return code.replace(/\t/g, tab);
};

/**
 * Replaces tabs with smart spaces.
 * 
 * @param {String} code    Code to fix the tabs in.
 * @param {Number} tabSize Number of spaces in a column.
 * @return {String}        Returns code with all tabs replaces with roper amount of spaces.
 */
function processSmartTabs(code, tabSize)
{
	var lines = splitLines(code),
		tab = '\t',
		spaces = ''
		;
	
	// Create a string with 1000 spaces to copy spaces from... 
	// It's assumed that there would be no indentation longer than that.
	for (var i = 0; i < 50; i++) 
		spaces += '                    '; // 20 spaces * 50
			
	// This function inserts specified amount of spaces in the string
	// where a tab is while removing that given tab.
	function insertSpaces(line, pos, count)
	{
		return line.substr(0, pos)
			+ spaces.substr(0, count)
			+ line.substr(pos + 1, line.length) // pos + 1 will get rid of the tab
			;
	};

	// Go through all the lines and do the 'smart tabs' magic.
	code = eachLine(code, function(line)
	{
		if (line.indexOf(tab) == -1) 
			return line;
		
		var pos = 0;
		
		while ((pos = line.indexOf(tab)) != -1) 
		{
			// This is pretty much all there is to the 'smart tabs' logic.
			// Based on the position within the line and size of a tab,
			// calculate the amount of spaces we need to insert.
			var spaces = tabSize - pos % tabSize;
			line = insertSpaces(line, pos, spaces);
		}
		
		return line;
	});
	
	return code;
};

/**
 * Performs various string fixes based on configuration.
 */
function fixInputString(str)
{
	var br = /<br\s*\/?>|&lt;br\s*\/?&gt;/gi;
	
	if (sh.config.bloggerMode == true)
		str = str.replace(br, '\n');

	if (sh.config.stripBrs == true)
		str = str.replace(br, '');
		
	return str;
};

/**
 * Removes all white space at the begining and end of a string.
 * 
 * @param {String} str   String to trim.
 * @return {String}      Returns string without leading and following white space characters.
 */
function trim(str)
{
	return str.replace(/^\s+|\s+$/g, '');
};

/**
 * Unindents a block of text by the lowest common indent amount.
 * @param {String} str   Text to unindent.
 * @return {String}      Returns unindented text block.
 */
function unindent(str)
{
	var lines = splitLines(fixInputString(str)),
		indents = new Array(),
		regex = /^\s*/,
		min = 1000
		;
	
	// go through every line and check for common number of indents
	for (var i = 0; i < lines.length && min > 0; i++) 
	{
		var line = lines[i];
		
		if (trim(line).length == 0) 
			continue;
		
		var matches = regex.exec(line);
		
		// In the event that just one line doesn't have leading white space
		// we can't unindent anything, so bail completely.
		if (matches == null) 
			return str;
			
		min = Math.min(matches[0].length, min);
	}
	
	// trim minimum common number of white space from the begining of every line
	if (min > 0) 
		for (var i = 0; i < lines.length; i++) 
			lines[i] = lines[i].substr(min);
	
	return lines.join('\n');
};

/**
 * Callback method for Array.sort() which sorts matches by
 * index position and then by length.
 * 
 * @param {Match} m1	Left object.
 * @param {Match} m2    Right object.
 * @return {Number}     Returns -1, 0 or -1 as a comparison result.
 */
function matchesSortCallback(m1, m2)
{
	// sort matches by index first
	if(m1.index < m2.index)
		return -1;
	else if(m1.index > m2.index)
		return 1;
	else
	{
		// if index is the same, sort by length
		if(m1.length < m2.length)
			return -1;
		else if(m1.length > m2.length)
			return 1;
	}
	
	return 0;
};

/**
 * Executes given regular expression on provided code and returns all
 * matches that are found.
 * 
 * @param {String} code    Code to execute regular expression on.
 * @param {Object} regex   Regular expression item info from <code>regexList</code> collection.
 * @return {Array}         Returns a list of Match objects.
 */ 
function getMatches(code, regexInfo)
{
	function defaultAdd(match, regexInfo)
	{
		return match[0];
	};
	
	var index = 0,
		match = null,
		matches = [],
		func = regexInfo.func ? regexInfo.func : defaultAdd
		;
	
	while((match = regexInfo.regex.exec(code)) != null)
	{
		var resultMatch = func(match, regexInfo);
		
		if (typeof(resultMatch) == 'string')
			resultMatch = [new sh.Match(resultMatch, match.index, regexInfo.css)];

		matches = matches.concat(resultMatch);
	}
	
	return matches;
};

/**
 * Turns all URLs in the code into <a/> tags.
 * @param {String} code Input code.
 * @return {String} Returns code with </a> tags.
 */
function processUrls(code)
{
	var gt = /(.*)((&gt;|&lt;).*)/;
	
	return code.replace(sh.regexLib.url, function(m)
	{
		var suffix = '',
			match = null
			;
		
		// We include &lt; and &gt; in the URL for the common cases like <http://google.com>
		// The problem is that they get transformed into &lt;http://google.com&gt;
		// Where as &gt; easily looks like part of the URL string.
	
		if (match = gt.exec(m))
		{
			m = match[1];
			suffix = match[2];
		}
		
		return '<a href="' + m + '">' + m + '</a>' + suffix;
	});
};

/**
 * Finds all <SCRIPT TYPE="syntaxhighlighter" /> elementss.
 * @return {Array} Returns array of all found SyntaxHighlighter tags.
 */
function getSyntaxHighlighterScriptTags()
{
	var tags = document.getElementsByTagName('script'),
		result = []
		;
	
	for (var i = 0; i < tags.length; i++)
		if (tags[i].type == 'syntaxhighlighter')
			result.push(tags[i]);
			
	return result;
};

/**
 * Strips <![CDATA[]]> from <SCRIPT /> content because it should be used
 * there in most cases for XHTML compliance.
 * @param {String} original	Input code.
 * @return {String} Returns code without leading <![CDATA[]]> tags.
 */
function stripCData(original)
{
	var left = '<![CDATA[',
		right = ']]>',
		// for some reason IE inserts some leading blanks here
		copy = trim(original),
		changed = false,
		leftLength = left.length,
		rightLength = right.length
		;
	
	if (copy.indexOf(left) == 0)
	{
		copy = copy.substring(leftLength);
		changed = true;
	}
	
	var copyLength = copy.length;
	
	if (copy.indexOf(right) == copyLength - rightLength)
	{
		copy = copy.substring(0, copyLength - rightLength);
		changed = true;
	}
	
	return changed ? copy : original;
};


/**
 * Quick code mouse double click handler.
 */
function quickCodeHandler(e)
{
	var target = e.target,
		highlighterDiv = findParentElement(target, '.syntaxhighlighter'),
		container = findParentElement(target, '.container'),
		textarea = document.createElement('textarea'),
		highlighter
		;

	if (!container || !highlighterDiv || findElement(container, 'textarea'))
		return;

	highlighter = getHighlighterById(highlighterDiv.id);
	
	// add source class name
	addClass(highlighterDiv, 'source');

	// Have to go over each line and grab it's text, can't just do it on the
	// container because Firefox loses all \n where as Webkit doesn't.
	var lines = container.childNodes,
		code = []
		;
	
	for (var i = 0; i < lines.length; i++)
		code.push(lines[i].innerText || lines[i].textContent);
	
	// using \r instead of \r or \r\n makes this work equally well on IE, FF and Webkit
	code = code.join('\r');
	
	// inject <textarea/> tag
	textarea.appendChild(document.createTextNode(code));
	container.appendChild(textarea);
	
	// preselect all text
	textarea.focus();
	textarea.select();
	
	// set up handler for lost focus
	attachEvent(textarea, 'blur', function(e)
	{
		textarea.parentNode.removeChild(textarea);
		removeClass(highlighterDiv, 'source');
	});
};

/**
 * Match object.
 */
sh.Match = function(value, index, css)
{
	this.value = value;
	this.index = index;
	this.length = value.length;
	this.css = css;
	this.brushName = null;
};

sh.Match.prototype.toString = function()
{
	return this.value;
};

/**
 * Simulates HTML code with a scripting language embedded.
 * 
 * @param {String} scriptBrushName Brush name of the scripting language.
 */
sh.HtmlScript = function(scriptBrushName)
{
	var brushClass = findBrush(scriptBrushName),
		scriptBrush,
		xmlBrush = new sh.brushes.Xml(),
		bracketsRegex = null,
		ref = this,
		methodsToExpose = 'getDiv getHtml init'.split(' ')
		;

	if (brushClass == null)
		return;
	
	scriptBrush = new brushClass();
	
	for(var i = 0; i < methodsToExpose.length; i++)
		// make a closure so we don't lose the name after i changes
		(function() {
			var name = methodsToExpose[i];
			
			ref[name] = function()
			{
				return xmlBrush[name].apply(xmlBrush, arguments);
			};
		})();
	
	if (scriptBrush.htmlScript == null)
	{
		alert(sh.config.strings.brushNotHtmlScript + scriptBrushName);
		return;
	}
	
	xmlBrush.regexList.push(
		{ regex: scriptBrush.htmlScript.code, func: process }
	);
	
	function offsetMatches(matches, offset)
	{
		for (var j = 0; j < matches.length; j++) 
			matches[j].index += offset;
	}
	
	function process(match, info)
	{
		var code = match.code,
			matches = [],
			regexList = scriptBrush.regexList,
			offset = match.index + match.left.length,
			htmlScript = scriptBrush.htmlScript,
			result
			;

		// add all matches from the code
		for (var i = 0; i < regexList.length; i++)
		{
			result = getMatches(code, regexList[i]);
			offsetMatches(result, offset);
			matches = matches.concat(result);
		}
		
		// add left script bracket
		if (htmlScript.left != null && match.left != null)
		{
			result = getMatches(match.left, htmlScript.left);
			offsetMatches(result, match.index);
			matches = matches.concat(result);
		}
		
		// add right script bracket
		if (htmlScript.right != null && match.right != null)
		{
			result = getMatches(match.right, htmlScript.right);
			offsetMatches(result, match.index + match[0].lastIndexOf(match.right));
			matches = matches.concat(result);
		}
		
		for (var j = 0; j < matches.length; j++)
			matches[j].brushName = brushClass.brushName;
			
		return matches;
	}
};

/**
 * Main Highlither class.
 * @constructor
 */
sh.Highlighter = function()
{
	// not putting any code in here because of the prototype inheritance
};

sh.Highlighter.prototype = {
	/**
	 * Returns value of the parameter passed to the highlighter.
	 * @param {String} name				Name of the parameter.
	 * @param {Object} defaultValue		Default value.
	 * @return {Object}					Returns found value or default value otherwise.
	 */
	getParam: function(name, defaultValue)
	{
		var result = this.params[name];
		return toBoolean(result == null ? defaultValue : result);
	},
	
	/**
	 * Shortcut to document.createElement().
	 * @param {String} name		Name of the element to create (DIV, A, etc).
	 * @return {HTMLElement}	Returns new HTML element.
	 */
	create: function(name)
	{
		return document.createElement(name);
	},
	
	/**
	 * Applies all regular expression to the code and stores all found
	 * matches in the `this.matches` array.
	 * @param {Array} regexList		List of regular expressions.
	 * @param {String} code			Source code.
	 * @return {Array}				Returns list of matches.
	 */
	findMatches: function(regexList, code)
	{
		var result = [];
		
		if (regexList != null)
			for (var i = 0; i < regexList.length; i++) 
				// BUG: length returns len+1 for array if methods added to prototype chain (oising@gmail.com)
				if (typeof (regexList[i]) == "object")
					result = result.concat(getMatches(code, regexList[i]));
		
		// sort and remove nested the matches
		return this.removeNestedMatches(result.sort(matchesSortCallback));
	},
	
	/**
	 * Checks to see if any of the matches are inside of other matches. 
	 * This process would get rid of highligted strings inside comments, 
	 * keywords inside strings and so on.
	 */
	removeNestedMatches: function(matches)
	{
		// Optimized by Jose Prado (http://joseprado.com)
		for (var i = 0; i < matches.length; i++) 
		{ 
			if (matches[i] === null)
				continue;
			
			var itemI = matches[i],
				itemIEndPos = itemI.index + itemI.length
				;
			
			for (var j = i + 1; j < matches.length && matches[i] !== null; j++) 
			{
				var itemJ = matches[j];
				
				if (itemJ === null) 
					continue;
				else if (itemJ.index > itemIEndPos) 
					break;
				else if (itemJ.index == itemI.index && itemJ.length > itemI.length)
					matches[i] = null;
				else if (itemJ.index >= itemI.index && itemJ.index < itemIEndPos) 
					matches[j] = null;
			}
		}
		
		return matches;
	},
	
	/**
	 * Creates an array containing integer line numbers starting from the 'first-line' param.
	 * @return {Array} Returns array of integers.
	 */
	figureOutLineNumbers: function(code)
	{
		var lines = [],
			firstLine = parseInt(this.getParam('first-line'))
			;
		
		eachLine(code, function(line, index)
		{
			lines.push(index + firstLine);
		});
		
		return lines;
	},
	
	/**
	 * Determines if specified line number is in the highlighted list.
	 */
	isLineHighlighted: function(lineNumber)
	{
		var list = this.getParam('highlight', []);
		
		if (typeof(list) != 'object' && list.push == null) 
			list = [ list ];
		
		return indexOf(list, lineNumber.toString()) != -1;
	},
	
	/**
	 * Generates HTML markup for a single line of code while determining alternating line style.
	 * @param {Integer} lineNumber	Line number.
	 * @param {String} code Line	HTML markup.
	 * @return {String}				Returns HTML markup.
	 */
	getLineHtml: function(lineIndex, lineNumber, code)
	{
		var classes = [
			'line',
			'number' + lineNumber,
			'index' + lineIndex,
			'alt' + (lineNumber % 2 == 0 ? 1 : 2).toString()
		];
		
		if (this.isLineHighlighted(lineNumber))
		 	classes.push('highlighted');
		
		if (lineNumber == 0)
			classes.push('break');
			
		return '<div class="' + classes.join(' ') + '">' + code + '</div>';
	},
	
	/**
	 * Generates HTML markup for line number column.
	 * @param {String} code			Complete code HTML markup.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns HTML markup.
	 */
	getLineNumbersHtml: function(code, lineNumbers)
	{
		var html = '',
			count = splitLines(code).length,
			firstLine = parseInt(this.getParam('first-line')),
			pad = this.getParam('pad-line-numbers')
			;
		
		if (pad == true)
			pad = (firstLine + count - 1).toString().length;
		else if (isNaN(pad) == true)
			pad = 0;
			
		for (var i = 0; i < count; i++)
		{
			var lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i,
				code = lineNumber == 0 ? sh.config.space : padNumber(lineNumber, pad)
				;
				
			html += this.getLineHtml(i, lineNumber, code);
		}
		
		return html;
	},
	
	/**
	 * Splits block of text into individual DIV lines.
	 * @param {String} code			Code to highlight.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns highlighted code in HTML form.
	 */
	getCodeLinesHtml: function(html, lineNumbers)
	{
		html = trim(html);
		
		var lines = splitLines(html),
			padLength = this.getParam('pad-line-numbers'),
			firstLine = parseInt(this.getParam('first-line')),
			html = '',
			brushName = this.getParam('brush')
			;

		for (var i = 0; i < lines.length; i++)
		{
			var line = lines[i],
				indent = /^(&nbsp;|\s)+/.exec(line),
				spaces = null,
				lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i;
				;

			if (indent != null)
			{
				spaces = indent[0].toString();
				line = line.substr(spaces.length);
				spaces = spaces.replace(' ', sh.config.space);
			}

			line = trim(line);
			
			if (line.length == 0)
				line = sh.config.space;
			
			html += this.getLineHtml(
				i,
				lineNumber, 
				(spaces != null ? '<code class="' + brushName + ' spaces">' + spaces + '</code>' : '') + line
			);
		}
		
		return html;
	},
	
	/**
	 * Returns HTML for the table title or empty string if title is null.
	 */
	getTitleHtml: function(title)
	{
		return title ? '<caption>' + title + '</caption>' : '';
	},
	
	/**
	 * Finds all matches in the source code.
	 * @param {String} code		Source code to process matches in.
	 * @param {Array} matches	Discovered regex matches.
	 * @return {String} Returns formatted HTML with processed mathes.
	 */
	getMatchesHtml: function(code, matches)
	{
		var pos = 0, 
			result = '',
			brushName = this.getParam('brush', '')
			;
		
		function getBrushNameCss(match)
		{
			var result = match ? (match.brushName || brushName) : brushName;
			return result ? result + ' ' : '';
		};
		
		// Finally, go through the final list of matches and pull the all
		// together adding everything in between that isn't a match.
		for (var i = 0; i < matches.length; i++) 
		{
			var match = matches[i],
				matchBrushName
				;
			
			if (match === null || match.length === 0) 
				continue;
			
			matchBrushName = getBrushNameCss(match);
			
			result += wrapLinesWithCode(code.substr(pos, match.index - pos), matchBrushName + 'plain')
					+ wrapLinesWithCode(match.value, matchBrushName + match.css)
					;

			pos = match.index + match.length + (match.offset || 0);
		}

		// don't forget to add whatever's remaining in the string
		result += wrapLinesWithCode(code.substr(pos), getBrushNameCss() + 'plain');

		return result;
	},
	
	/**
	 * Generates HTML markup for the whole syntax highlighter.
	 * @param {String} code Source code.
	 * @return {String} Returns HTML markup.
	 */
	getHtml: function(code)
	{
		var html = '',
			classes = [ 'syntaxhighlighter' ],
			tabSize,
			matches,
			lineNumbers
			;
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;

		className = 'syntaxhighlighter';

		if (this.getParam('collapse') == true)
			classes.push('collapsed');
		
		if ((gutter = this.getParam('gutter')) == false)
			classes.push('nogutter');

		// add custom user style name
		classes.push(this.getParam('class-name'));

		// add brush alias to the class name for custom CSS
		classes.push(this.getParam('brush'));

		code = trimFirstAndLastLines(code)
			.replace(/\r/g, ' ') // IE lets these buggers through
			;

		tabSize = this.getParam('tab-size');

		// replace tabs with spaces
		code = this.getParam('smart-tabs') == true
			? processSmartTabs(code, tabSize)
			: processTabs(code, tabSize)
			;

		// unindent code by the common indentation
		code = unindent(code);

		if (gutter)
			lineNumbers = this.figureOutLineNumbers(code);
		
		// find matches in the code using brushes regex list
		matches = this.findMatches(this.regexList, code);
		// processes found matches into the html
		html = this.getMatchesHtml(code, matches);
		// finally, split all lines so that they wrap well
		html = this.getCodeLinesHtml(html, lineNumbers);

		// finally, process the links
		if (this.getParam('auto-links'))
			html = processUrls(html);
		
		if (typeof(navigator) != 'undefined' && navigator.userAgent && navigator.userAgent.match(/MSIE/))
			classes.push('ie');
		
		html = 
			'<div id="' + getHighlighterId(this.id) + '" class="' + classes.join(' ') + '">'
				+ (this.getParam('toolbar') ? sh.toolbar.getHtml(this) : '')
				+ '<table border="0" cellpadding="0" cellspacing="0">'
					+ this.getTitleHtml(this.getParam('title'))
					+ '<tbody>'
						+ '<tr>'
							+ (gutter ? '<td class="gutter">' + this.getLineNumbersHtml(code) + '</td>' : '')
							+ '<td class="code">'
								+ '<div class="container">'
									+ html
								+ '</div>'
							+ '</td>'
						+ '</tr>'
					+ '</tbody>'
				+ '</table>'
			+ '</div>'
			;
			
		return html;
	},
	
	/**
	 * Highlights the code and returns complete HTML.
	 * @param {String} code     Code to highlight.
	 * @return {Element}        Returns container DIV element with all markup.
	 */
	getDiv: function(code)
	{
		if (code === null) 
			code = '';
		
		this.code = code;

		var div = this.create('div');

		// create main HTML
		div.innerHTML = this.getHtml(code);
		
		// set up click handlers
		if (this.getParam('toolbar'))
			attachEvent(findElement(div, '.toolbar'), 'click', sh.toolbar.handler);
		
		if (this.getParam('quick-code'))
			attachEvent(findElement(div, '.code'), 'dblclick', quickCodeHandler);
		
		return div;
	},
	
	/**
	 * Initializes the highlighter/brush.
	 *
	 * Constructor isn't used for initialization so that nothing executes during necessary
	 * `new SyntaxHighlighter.Highlighter()` call when setting up brush inheritence.
	 *
	 * @param {Hash} params Highlighter parameters.
	 */
	init: function(params)
	{
		this.id = guid();
		
		// register this instance in the highlighters list
		storeHighlighter(this);
		
		// local params take precedence over defaults
		this.params = merge(sh.defaults, params || {})
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;
	},
	
	/**
	 * Converts space separated list of keywords into a regular expression string.
	 * @param {String} str    Space separated keywords.
	 * @return {String}       Returns regular expression string.
	 */
	getKeywords: function(str)
	{
		str = str
			.replace(/^\s+|\s+$/g, '')
			.replace(/\s+/g, '|')
			;
		
		return '\\b(?:' + str + ')\\b';
	},
	
	/**
	 * Makes a brush compatible with the `html-script` functionality.
	 * @param {Object} regexGroup Object containing `left` and `right` regular expressions.
	 */
	forHtmlScript: function(regexGroup)
	{
		this.htmlScript = {
			left : { regex: regexGroup.left, css: 'script' },
			right : { regex: regexGroup.right, css: 'script' },
			code : new XRegExp(
				"(?<left>" + regexGroup.left.source + ")" +
				"(?<code>.*?)" +
				"(?<right>" + regexGroup.right.source + ")",
				"sgi"
				)
		};
	}
}; // end of Highlighter

return sh;
}(); // end of anonymous function

// CommonJS
typeof(exports) != 'undefined' ? exports['SyntaxHighlighter'] = SyntaxHighlighter : null;
</script>

<script type="text/javascript">// (inc clojure-brush) ;; an improved SyntaxHighlighter brush for clojure
//
// Copyright (C) 2011 Andrew Brehaut
//
// Distributed under the Eclipse Public License, the same as Clojure.
//
// https://github.com/brehaut/inc-clojure-brush
//
// Written by Andrew Brehaut
// V0.9.1, November 2011

if (typeof net == "undefined") net = {};
if (!(net.brehaut)) net.brehaut = {};

net.brehaut.ClojureTools = (function (SH) {
  "use strict";
  // utiliies
  if (!Object.create) Object.create = function object(o) {
    function F() {};
    F.prototype = o;  
    return new F();
  };
        
  // data
  
  function Token(value, index, tag, length) {
    this.value = value;
    this.index = index;
    this.length = length || value.length;
    this.tag = tag;
    this.secondary_tags = {};
  }
  
  // null_token exists so that LispNodes that have not had a closing tag attached
  // can have a dummy token to simplify annotation
  var null_token = new Token("", -1, "null", -1);
  
  /* LispNodes are aggregate nodes for sexpressions. 
   *
   */
  function LispNode(tag, children, opening) {
    this.tag = tag;            // current metadata for syntax inference
    this.parent = null;        // the parent expression
    this.list = children;      // all the child forms in order
    this.opening = opening;    // the token that opens this form.
    this.closing = null_token; // the token that closes this form.
    this.meta = null;          // metadata nodes will be attached here if they are found
  }

  var null_lispnode = new LispNode("null", [], null_token);

  
  function PrefixNode(tag, token, attached_node) {
    this.tag = tag;
    this.token = token;
    this.attached_node = attached_node;
    this.parent = null;
  }

  
  
  // tokenize

  function tokenize(code) {
    var tokens = [];
    var tn = 0;
    
    var zero = "0".charCodeAt(0);
    var nine = "9".charCodeAt(0); 
    var lower_a = "a".charCodeAt(0);
    var lower_f = "f".charCodeAt(0);    
    var upper_a = "A".charCodeAt(0);
    var upper_f = "F".charCodeAt(0);
    
    var dispatch = false; // have we just seen a # character?
    
    // i tracks the start of the current window
    // extent is the window for slicing
    
    for (var i = 0, 
             extent = i, 
             j = code.length; 
             i < j && extent <= j;) {          
                
      var c = code[i];
      
      // we care about capturing the whole token when dispatch is used, so back up the
      // starting index by 1
      if (dispatch) i--; 
      
      switch (c) {
        // dispatch alters the value of the next thing read
        case "#":
          dispatch = true;
          i++;
          extent++;
          continue;
          
        case " ":    // ignore whitespace
        case "\t":
        case "\n":
        case "\r":
        case ",":   
          extent++
          break; 
          
        // simple terms
        case "^":
        case "`":
        case ")":
        case "[":
        case "]":
        case "}":
        case "@":
          tokens[tn++] = new Token(c, i, c, ++extent - i);
          break;
        
        case "'":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#'" : "'", extent - i);
          break
        
        case "(":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "(", extent - i);
          break;          
          
        case "{":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#{" : "{", extent - i);
          break;  
        
        case "\\":
          if (code.slice(i + 1, i + 8) === "newline") {
            tokens[tn++] = new Token("\\newline", i, "value", 8);
            extent = i + 9; 
          }
          else if (code.slice(i + 1, i + 6) === "space") {
            tokens[tn++] = new Token("\\space", i, "value", 6);
            extent = i + 6;
          }
          else if (code.slice(i + 1, i + 4) === "tab") {
            tokens[tn++] = new Token("\\tab", i, "value", 4);
            extent = i + 5;
          } // work around fun bug with &,>,< in character literals
          else if (code.slice(i + 1, i + 6) === "&amp;") {
            tokens[tn++] = new Token("\\&amp;", i, "value", 6);
            extent = i + 6; 
          }
          else if (code.slice(i + 1, i + 5) === "&lt;") {
            tokens[tn++] = new Token("\\&lt;", i, "value", 5);
            extent = i + 5;
          }
          else if (code.slice(i + 1, i + 5) === "&gt;") {
            tokens[tn++] = new Token("\\&gt;", i, "value", 5);
            extent = i + 5;
          }
          
          else {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "value", 2);
          }
          break;
        
        case "~": // slice
          if (code[i + 1] === "@") {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "splice", 2);
          }
          else {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "unquote", 2);
          }
          break;
        
        // complicated terms
        case "\"": // strings and regexps
          for (extent++; extent <= j; extent++) {
            if (code[extent] === "\\") extent++;
            else if (code[extent] === "\"") break;
          }
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "regexp" : "string", extent - i);       
          break;
          
        case ";":
          for (; extent <= j && code[extent] !== "\n" && code[extent] !== "\r"; extent++);
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "comments", extent - i);   
          break;
        
        case "+": // numbers; fall through to symbol for + and - not prefixing a number
        case "-":
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
        // todo: exponents, hex
        // http://my.safaribooksonline.com/9781449310387/14?reader=pf&readerfullscreen=&readerleftmenu=1
          var c2 = code.charCodeAt(i + 1);
          if (((c === "+" || c === "-") && (c2 >= zero && c2 <= nine)) // prefixes
              || (c !== "+" && c !== "-")) {
            if (c === "+" || c === "-") extent++; 
            for (; extent <= j; extent++) {
              var charCode = code.charCodeAt(extent);
              if (charCode < zero || charCode > nine) break;
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "r" || c === "R" || c === "/" || c === ".") // interstitial characters
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "x" || c === "X") && 
                ((c2 >= zero && c2 <= nine) 
                 || (c2 >= lower_a && c2 <= lower_f)
                 || (c2 >= upper_a && c2 <= upper_f))) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (((charCode >= zero && charCode <= nine) 
                    || (charCode >= lower_a && charCode <= lower_f)
                    || (charCode >= upper_a && charCode <= upper_f))) continue;
                break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "e" || c === "E") 
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            if (c === "N" || c === "M") extent++;

            tokens[tn++] = new Token(code.slice(i, extent), i, "value", extent - i);
            break;
          }

        case "_":
          if (dispatch && c === "_") {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "skip", extent - i);
            break;
          } // if not a skip, fall through to symbols
        
        // Allow just about any other symbol as a symbol. This is far more permissive than 
        // clojure actually allows, but should catch any weirdo crap that accidentally gets
        // into the code.
        default: 
          for (extent++; extent <= j; extent++) {
            switch (code[extent]) {
              case " ":
              case "\t":
              case "\n":
              case "\r":
              case "\\":
              case ",":
              case "{":
              case "}":
              case "(":
              case ")":
              case "[":
              case "]":
              case "^":
              case "`":
              case "@":   
                break;
              case ";":   
                // theres a weird bug via syntax highligher that gives us escaped entities.
                // need to watch out for these
                if (code.slice(extent-3, extent+1) === "&lt;"
                    ||code.slice(extent-3, extent+1) === "&gt;"
                    ||code.slice(extent-4, extent+1) === "&amp;") {
                  continue;
                }
                break;
              default:
                continue;
            }
            break;
          }
          
          var value = code.slice(i, extent);
          var tag = "symbol";
          if (value[0] == ":") {
            tag = "keyword";
          }
          else if (value === "true" || value === "false" || value === "nil") {
            tag = "value";
          }
          tokens[tn++] = new Token(value, i, tag, extent - i);
      }
      
      dispatch = false;
      i = extent;
    } 

    return tokens;
  }


  function build_tree(tokens) {
    var toplevel = {
      list: [], 
      tag: "toplevel", 
      parent: null, 
      opening: null,
      closing: null,
      depth: -1
    };
    
    // loop variables hoisted out as semi globals to track position in token stream
    var i = -1;
    var j = tokens.length;
    
    function parse_one(t) {
      // ignore special tokens and forms that dont belong in the tree
      for (; t && (t.tag === "comments" || t.tag === "invalid" || t.tag == "skip") && i < j; ) {
        if (t.tag === "skip") {
          t.tag = "preprocessor";
          annotate_comment(parse_one(tokens[++i]));
        }
        t = tokens[++i];
      }
      
      if (!t) return {}; // hackity hack
      
      switch (t.tag) {
        case "{":
          return build_aggregate(new LispNode("map", [], t), "}");
        case "(":
          return build_aggregate(new LispNode("list", [], t), ")");
        case "#{":
          return build_aggregate(new LispNode("set", [], t), "}");
        case "[":
          return build_aggregate(new LispNode("vector", [], t), "]");
        case "'":
          return new PrefixNode("quote", t, parse_one(tokens[++i]));
        case "#'":
          return new PrefixNode("varquote", t, parse_one(tokens[++i]));  
        case "@":
          return new PrefixNode("deref", t, parse_one(tokens[++i]));  
        case "`":
          return new PrefixNode("quasiquote", t, parse_one(tokens[++i]));  
        case "unquote":
          return new PrefixNode("unquote", t, parse_one(tokens[++i]));
        case "splice":
          return new PrefixNode("splice", t, parse_one(tokens[++i]));  
        case "^":
          t.tag = "meta";
          var meta = parse_one(tokens[++i]);
          var next = parse_one(tokens[++i]);
          next.meta = meta;
          return next;
      }
      
      return t;
    }
    
    // build_aggregate collects to ether sub forms for one aggregate for. 
    function build_aggregate(current, expected_closing) {
      for (i++; i < j; i++) {
        var t = tokens[i];

        if (t.tag === "}" || t.tag === ")" || t.tag === "]") {
          if (t.tag !== expected_closing) t.tag = "invalid";
          current.closing = t;
          if (expected_closing) return current;
        }
        var node = parse_one(t);

        node.parent = current;
        current.list[current.list.length] = node;
      }
      
      return current;
    }
    
    build_aggregate(toplevel, null);
    
    return toplevel;
  }

  // annotation rules to apply to a form based on its head

  var show_locals = true;  // HACK. would rather not use a (semi)-global.

  /* annotate_comment is a special case annotation. 
   * in addition to its role in styling specific forms, it is called by parse_one to
   * ignore any forms skipped with #_
   */ 
  function annotate_comment(exp) {
    exp.tag = "comments";

    if (exp.list) {
      exp.opening.tag = "comments";
      exp.closing.tag = "comments";
    
      for (var i = 0; i < exp.list.length; i++) {
        var child = exp.list[i];
        if (child.list) {
          annotate_comment(child);
        }
        if (child.attached_node) {
          annotate_comment(child.attached_node);
        }
        else {
          child.tag = "comments";
        }
      }
    }
  }

  /* custom annotation rules are stored here */
  var annotation_rules = {};
  
  // this function is exposed to allow ad hoc extension of the customisation rules
  function register_annotation_rule(names, rule) {
    for (var i = 0; i < names.length; i++) {
      annotation_rules[names[i]] = rule;
    }
  }


  function annotate_destructuring (exp, scope) {
    if (exp.list) {
      if (exp.tag === "vector") {
        for (var i = 0; i < exp.list.length; i++) {
          annotate_destructuring(exp.list[i], scope);
        }
      } 
      else if (exp.tag === "map") {
        for (var i = 0; i < exp.list.length; i += 2) {
          var key = exp.list[i];
          var val = exp.list[i + 1];
          
          if (key.tag === "keyword" && val.tag === "vector") {
            for (var ii = 0, jj = val.list.length; ii < jj; ii++) {
              if (val.list[ii].tag !== "symbol") continue;
              val.list[ii].tag = "variable";
              scope[val.list[ii].value] = true;
            }
          }
          else {
            annotate_destructuring(key, scope);
            annotate_expressions(val, scope);
          }
        } 
      }
    } 
    else if (exp.tag === "symbol" && (exp.value !== "&" && exp.value !== "&amp;")){
      exp.tag = "variable";
      scope[exp.value] = true;
    }
  }

  function _annotate_binding_vector (exp, scope) {
    if (exp.tag !== "vector") return;
  
    var bindings = exp.list;

    if (bindings.length % 2 === 1) return;
    
    for (var i = 0; i < bindings.length; i += 2) {
      annotate_destructuring(bindings[i], scope);
      annotate_expressions(bindings[i + 1], scope);
    }    
  }

  function annotate_binding (exp, scope) {
    var bindings = exp.list[1];
    if (!show_locals) return; // HACK

    if (bindings) {
      scope = Object.create(scope);
      _annotate_binding_vector(bindings, scope);
    }
    for (var i = 2; i < exp.list.length; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function _annotate_function_body (exp, scope, start_idx) {
    var argvec = exp.list[start_idx];
    if (argvec.tag !== "vector") return;

    scope = Object.create(scope);

    for (var i = 0, j = argvec.list.length; i < j; i++) {
      annotate_destructuring(argvec.list[i], scope);
    }
    
    for (var i = start_idx, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function annotate_function (exp, scope) {
    for (var i = 1, j = exp.list.length; i < j; i++) {
      var child = exp.list[i];
      
      if (child.tag === "vector") {
        _annotate_function_body (exp, scope, i);
        return;
      }
      else if (child.tag === "list") {
        _annotate_function_body(child, scope, 0)
      }
    }
  }
  
  function annotate_letfn (exp, scope) {
    scope = Object.create(scope);
    var bindings = exp.list[1];
    
    var fn;
    for (var i = 0, j = bindings.list.length; i < j; i++) {
      fn = bindings.list[i];
      if (!fn.list[0]) continue;
      fn.list[0].tag = "variable";
      scope[fn.list[0].value] = true;
    }
    
    for (i = 0, j = bindings.list.length; i < j; i++) {
      var fn = bindings.list[i];
      annotate_function(fn, scope);
    }
    
    for (i = 2, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }

  register_annotation_rule(
    ["comment"],
    annotate_comment
  );
  
  register_annotation_rule(
    ["let", "when-let", "if-let", "binding", "doseq", "for", "dotimes", "let*"],
    annotate_binding
  );
  
  register_annotation_rule(
    ["defn", "defn-", "fn", "bound-fn", "defmacro", "fn*", "defmethod"],
    annotate_function
  );
  
  register_annotation_rule(
    ["letfn"],
    annotate_letfn
  );

  // standard annotations

  function _annotate_metadata_recursive(meta, scope) {
    if (!meta) return;

    if (meta.list !== undefined && meta.list !== null) {
      for (var i = 0, j = meta.list.length; i < j; i++) {
        meta.opening.secondary_tags.meta = true
        meta.closing.secondary_tags.meta = true
        _annotate_metadata_recursive(meta.list[i], scope);
      }
    }
    else if (meta.attached_node) {
      meta.token.secondary_tags.meta = true;
      _annotate_metadata_recursive(meta.attached_node, scope);
    }
    else {
      meta.secondary_tags.meta = true;
    }
  }
  
  function annotate_metadata(exp) {
    if (!(exp && exp.meta)) return;
    var meta = exp.meta;
    
     annotate_expressions(meta, {});    
    _annotate_metadata_recursive(meta, {});
  }


  function annotate_quoted(exp, scope) {
    if (!exp) return;

    if (exp.list !== undefined && exp.list !== null) {
      for (var i = 0, j = exp.list.length; i < j; i++) {
        exp.opening.secondary_tags.quoted = true
        exp.closing.secondary_tags.quoted = true
        annotate_quoted(exp.list[i], scope);
      }
    }
    else if (exp.attached_node) {
      if (exp.tag === "unquote" || exp.tag === "splice") return;
      exp.token.secondary_tags.quoted = true;
      annotate_quoted(exp.attached_node, scope);
    }
    else {
      exp.secondary_tags.quoted = true;
    }
  }


  function annotate_expressions(exp, scope) {
    annotate_metadata(exp);
    
    switch (exp.tag) {
      case "toplevel": 
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "list": // functions, macros, special forms, comments
        var head = exp.list[0];
      
        if (head) {
          if (head.tag === "list" || head.tag === "vector" 
           || head.tag === "map" || head.tag === "set") {
            annotate_expressions(head, scope);
          }
          else if (head.attached_node) {
            annotate_expressions(head.attached_node, scope);
          }
          else {
            head.tag = (head.value.match(/(^\.)|(\.$)|[A-Z].*\//)
                        ? "method"
                        : "function");
          }

          // apply specific rules
          if (annotation_rules.hasOwnProperty(head.value)) {
            annotation_rules[head.value](exp, scope);
          } 
          else {
            for (var i = 1; i < exp.list.length; i++) {
              annotate_expressions(exp.list[i], scope);
            }
          } 
        }
        else { // empty list
          exp.opening.tag = "value";
          exp.closing.tag = "value";
        }
      
        break;
      
      case "vector": // data
      case "map":
      case "set":
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "symbol":
        if (exp.value.match(/[A-Z].*\/[A-Z_]+/)) {
          exp.tag = "constant";
        }
        else if (show_locals && scope[exp.value]) {
          exp.tag = "variable";
        }
        else if (exp.tag === "symbol" && exp.value.match(/([A-Z].*\/)?[A-Z_]+/)) {
          exp.tag = "type";
        }
        break;
      
      case "quote":
      case "quasiquote":
        annotate_quoted(exp.attached_node, scope);
        
      default:
        if (exp.attached_node) annotate_expressions(exp.attached_node, scope);
    }
  }

  // translation of tag to css:
  var css_translation = {
    "constant":     "constants",
    "keyword":      "constants",
    "method":       "color1",
    "type":         "color3", 
    "function":     "functions",
    "string":       "string",
    "regexp":       "string",
    "value":        "value",
    "comments":     "comments",
    "symbol":       "symbol",
    "variable":     "variable",
    "splice":       "preprocessor", 
    "unquote":      "preprocessor",     
    "preprocessor": "preprocessor",
    "meta":         "preprocessor", 
    "'":            "preprocessor", 
    "#'":           "preprocessor",    
    "(":            "plain",
    ")":            "plain",
    "{":            "keyword",
    "}":            "keyword",
    "#{":           "keyword",   
    "[":            "keyword",
    "]":            "keyword",
    "invalid":      "invalid",
    "@":            "plain" 
  };
  
  function translate_tags_to_css(tokens) {
    for (var i = 0, j = tokens.length; i < j; i++) {
      var token = tokens[i];
      token.css = css_translation[token.tag];
      for (var k in token.secondary_tags) if (token.secondary_tags.hasOwnProperty(k))
        token.css += " " + k ;
    };
  }
  
  
  // create the new brush

  SH.brushes.Clojure = function () {};
  SH.brushes.Clojure.prototype = new SyntaxHighlighter.Highlighter();
  
  SH.brushes.Clojure.prototype.findMatches = function find_matches (regexpList, code) {
    // this is a nasty global hack. need to resolve this
    if (this.params && this.params.locals) {
      show_locals = this.params.locals === true || this.params.locals === "true"; 
    }
    else {
      show_locals = true;
    }
    
    var tokens = tokenize(code);
    annotate_expressions(build_tree(tokens), {});
    translate_tags_to_css(tokens);

    return tokens;
  };
  
  SH.brushes.Clojure.aliases = ['clojure', 'Clojure', 'clj'];
  SH.brushes.Clojure.register_annotation_rule = register_annotation_rule;

  return {
    tokenize: tokenize,
    build_tree: build_tree
  };
})(SyntaxHighlighter);
</script>











<style>
  td.docs
  {
    max-width: 100%;
    width: 100%;
    padding-left: 0;
  }
</style>


































    <table><tr><td class="docs"><div class="header"><h1 class="project-name"><a href="https://github.com/hale/cryptopals">hale.cryptopals</a></h1><h2 class="project-version">0.1.0-SNAPSHOT</h2><br /><p>Cryptopals challenges in Clojure. <img src="https://circleci.com/gh/hale/cryptopals.svg?style=svg" alt="CircleCI" /></p>

<p><a href="https://cryptopals.com/">A collection of 48 exercises that demonstrate attacks on real-world crypto.</a></p>

<p>This is a different way to learn about crypto than taking a class or reading a
book. We give you problems to solve. They're derived from weaknesses in
real-world systems and modern cryptographic constructions. We give you enough
info to learn about the underlying crypto concepts yourself. When you're
finished, you'll not only have learned a good deal about how cryptosystems are
built, but you'll also understand how they're attacked.</p>

<p><strong>Work in progress:</strong></p>

<ul>
<li><s>Start</s> 24th May 2018</li>
<li><s>Set 1</s> 17th June 2018</li>
<li>Set 2</li>
<li>Set 3</li>
<li>Set 4</li>
<li>Set 5</li>
<li>Set 6</li>
<li>Set 7</li>
<li>Set 8</li>
</ul>
</div><div class="dependencies"><h3>dependencies</h3><table><tr><td class="dep-name">org.clojure/clojure</td><td class="dotted"><hr /></td><td class="dep-version">1.9.0</td></tr></table></div></td><td class="codes" style="text-align: center; vertical-align: middle;color: #666;padding-right:20px"><br /><br /><br />(this space intentionally left almost blank)</td></tr><tr><td class="docs"><div class="toc"><a name="toc"><h3>namespaces</h3></a><ul><li><a href="#hale.cryptopals.set1">hale.cryptopals.set1</a></li><li><a href="#hale.cryptopals.set1.challenge1">hale.cryptopals.set1.challenge1</a></li><li><a href="#hale.cryptopals.set1.challenge2">hale.cryptopals.set1.challenge2</a></li><li><a href="#hale.cryptopals.set1.challenge3">hale.cryptopals.set1.challenge3</a></li><li><a href="#hale.cryptopals.set1.challenge4">hale.cryptopals.set1.challenge4</a></li><li><a href="#hale.cryptopals.set1.challenge5">hale.cryptopals.set1.challenge5</a></li><li><a href="#hale.cryptopals.set1.challenge6">hale.cryptopals.set1.challenge6</a></li><li><a href="#hale.cryptopals.set1.challenge7">hale.cryptopals.set1.challenge7</a></li><li><a href="#hale.cryptopals.set1.challenge8">hale.cryptopals.set1.challenge8</a></li><li><a href="#hale.cryptopals.set2">hale.cryptopals.set2</a></li><li><a href="#hale.cryptopals.set2.challenge9">hale.cryptopals.set2.challenge9</a></li><li><a href="#hale.cryptopals.utils">hale.cryptopals.utils</a></li></ul></div></td><td class="codes">&nbsp;</td></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#hale.cryptopals.set1" name="hale.cryptopals.set1"><h1 class="project-name">hale.cryptopals.set1</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><h1>Crypto Challenge Set 1</h1>

<p>This is the <strong>qualifying set</strong>. We picked the exercises in it to ramp
developers up gradually into coding cryptography, but also to verify that we
were working with people who were ready to write code.</p>

<p>This set is <strong>relatively easy</strong>. With one exception, most of these exercises
should take only a couple minutes. But don't beat yourself up if it takes
longer than that. It took Alex two weeks to get through the set!</p>

<p>If you've written any crypto code in the past, you're going to feel like
skipping a lot of this. <strong>Don't skip them</strong>. At least two of them (we won't
say which) are important stepping stones to later attacks.</p>
</td><td class="codes"><pre class="brush: clojure">(ns hale.cryptopals.set1)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#hale.cryptopals.set1.challenge1" name="hale.cryptopals.set1.challenge1"><h1 class="project-name">hale.cryptopals.set1.challenge1</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><h1>Base64 encode a hex string</h1>

<p>The string:</p>

<pre><code>49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d
</code></pre>

<p>Should produce:</p>

<pre><code>SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t
</code></pre>

<p>So go ahead and make that happen. You'll need to use this code for the rest
of the exercises.</p>

<p>Cryptopals Rule: Always operate on raw bytes, never on encoded strings. Only use hex and base64 for pretty-printing.</p>
</td><td class="codes"><pre class="brush: clojure">(ns hale.cryptopals.set1.challenge1
  (:require [clojure.set :refer [map-invert]]
            [clojure.string :as str]
            [hale.cryptopals.utils :as utils]
            [clojure.test :as t]))</pre></td></tr><tr><td class="docs"><p>Axiomatic Base64 map of six-bit bytes (indices) to ASCII characters</p>

<p>The following table visually explains the process of Base64 encoding:</p>

<p><img src="https://pghale.com/images/cryptopals/base64-wiki-table.png" width="100%" /></p>

<ol>
<li>Get the underlying bytestream of the input data. (In the table they are
encoding the <em>ASCII</em> word "Man" wherease the exercise has us encode <em>hex</em>)</li>
<li>Parse the bytestream in chunks of six and turn each six-bit sequence into a
byte by padding with 2 empty bits (zeros). You can see in the image how
the remaining two bits from the first byte are used to generate the next
byte, etc until all input bytes are consumed.</li>
<li>Use the decimal value of each six-bit byte to 'lookup' the ASCII char in the
map. Because there is only six bits of information in each 'byte', the bit
pattern will always resolve to one of the 64 characters in the Base64
encoding map. This is because there are only 64 possible patterns in six
bits of information (n bits yield 2^n patterns).</li>
</ol>

<p>I had originally thought to write an algorithm that processed the list
recusively in blocks of 6. However, this is not possible because the smallest
unit in the JVM is a Byte. So instead we must process the bytestream in
groups of four and use bitwise operators to shift the bits around in each
byte.</p>

<p>The initial step of parsing hexidecimal strings as bytes is in the utils
namespace, as it's something we'll be using a lot in these exercises.</p>

<hr />
</td><td class="codes"><pre class="brush: clojure">(def base64-map
  {  0 \A  1 \B  2 \C  3 \D  4 \E  5 \F  6 \G  7 \H
     8 \I  9 \J 10 \K 11 \L 12 \M 13 \N 14 \O 15 \P
    16 \Q 17 \R 18 \S 19 \T 20 \U 21 \V 22 \W 23 \X
    24 \Y 25 \Z 26 \a 27 \b 28 \c 29 \d 30 \e 31 \f
    32 \g 33 \h 34 \i 35 \j 36 \k 37 \l 38 \m 39 \n
    40 \o 41 \p 42 \q 43 \r 44 \s 45 \t 46 \u 47 \v
    48 \w 49 \x 50 \y 51 \z 52 \0 53 \1 54 \2 55 \3
    56 \4 57 \5 58 \6 59 \7 60 \8 61 \9 62 \+ 63 \/ })</pre></td></tr><tr><td class="docs"><p>Base64 byte-expansion procedure, to reduce the number of possible values per
  byte from 256 to 64.</p>
</td><td class="codes"><pre class="brush: clojure">(defn base64-expand-bytes
  ([b1]
   (let [c1 (bit-shift-right b1 2)
         c2 (bit-or (bit-shift-left (bit-and 2r00000011 b1) 4)
                    (byte 0))]
     [c1 c2 nil nil]))
  ([b1 b2]
   (let [c1 (bit-shift-right b1 2)
         c2 (bit-or (bit-shift-left (bit-and 2r00000011 b1) 4)
                    (bit-shift-right b2 4))
         c3 (bit-or (bit-shift-left (bit-and 2r00001111 b2) 2)
                    (byte 0))]
     [c1 c2 c3 nil]))
  ([b1 b2 b3]
   (let [c1 (bit-shift-right b1 2)                             ; first 6 bits of b1
         c2 (bit-or (bit-shift-left (bit-and 2r00000011 b1) 4) ; last 2 bits of b1 plus first 4 bits of b2
                    (bit-shift-right b2 4))
         c3 (bit-or (bit-shift-left (bit-and 2r00001111 b2) 2) ; last 4 bits of b2 plus first 2 bits of b3
                    (bit-shift-right b3 6))
         c4 (bit-and 2r00111111 b3)]                           ; last 6 bits of b3
   [c1 c2 c3 c4])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(t/deftest test-base64-expand-bytes
  (t/is (= (apply base64-expand-bytes [2r01001101 2r01100001 2r01101110])
           [2r00010011 2r00010110 2r00000101 2r00101110] [19 22 5 46]))
  (t/is (= (apply base64-expand-bytes (map byte [77 97 110]))
           (map byte [19 22 5 46])))
  (t/is (= (apply base64-expand-bytes (map byte [77 0 0]))
           (map byte [19 16 0 0])))
  (t/is (= (apply base64-expand-bytes (map byte [77 97 0]))
           (map byte [19 22 4 0]))))</pre></td></tr><tr><td class="docs"><p>Base64 encode a stream of bytes</p>
</td><td class="codes"><pre class="brush: clojure">(defn base64-encode
  [bytes]
  (let [triples (partition 3 3 [] bytes)
        quads   (map (partial apply base64-expand-bytes) triples)
        chars   (map (fn [k] (get base64-map k \=)) (flatten quads))]
    (apply str chars)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def base64-encode-str (comp base64-encode utils/str-to-bytes))</pre></td></tr><tr><td class="docs"><p>Test vectors from <a href="https://tools.ietf.org/html/rfc4648#section-10">RFC4648</a></p>
</td><td class="codes"><pre class="brush: clojure">(t/deftest test-base64-encode
  (t/is (=          (base64-encode-str )))
  (t/is (= &quot;Zg==&quot;     (base64-encode-str &quot;f&quot;)))
  (t/is (= &quot;Zm8=&quot;     (base64-encode-str &quot;fo&quot;)))
  (t/is (= &quot;Zm9v&quot;     (base64-encode-str &quot;foo&quot;)))
  (t/is (= &quot;Zm9vYg==&quot; (base64-encode-str &quot;foob&quot;)))
  (t/is (= &quot;Zm9vYmE=&quot; (base64-encode-str &quot;fooba&quot;)))
  (t/is (= &quot;Zm9vYmFy&quot; (base64-encode-str &quot;foobar&quot;))))</pre></td></tr><tr><td class="docs"><p>Set 1 :: Challenge 1 :: Base64 encode a hex string</p>
</td><td class="codes"><pre class="brush: clojure">(def hex-to-base64
  (comp base64-encode utils/hex-to-bytes))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(t/deftest test-hex-to-base64
  (t/is (= (hex-to-base64
            (str &quot;49276d206b696c6c696e6720796f757220627261696e206c&quot;
                 &quot;696b65206120706f69736f6e6f7573206d757368726f6f6d&quot;))
            &quot;SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t&quot;)))</pre></td></tr><tr><td class="docs"><h2>Decode</h2>

<p>Decoding reads from the above table backwards:</p>

<ol>
<li>Reverse lookup the Base64 map to get the index.</li>
<li>Remove the 2 bits of padding from each byte until we end up with regular
8-bit bytes again.</li>
</ol>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def base64-chars (set (vals base64-map)))</pre></td></tr><tr><td class="docs"><p>Base64 reinflation procedure, to remove the zero-padding and turn the
  sequence of six-bit bytes back in to regular 8-bit bytes.</p>
</td><td class="codes"><pre class="brush: clojure">(defn base64-reduce-bytes
  ([b1 b2]
   (let [c1 (bit-or (bit-shift-left b1 2)
                    (bit-shift-right b2 4))]
     [c1]))
  ([b1 b2 b3]
   (let [c1 (bit-or (bit-shift-left b1 2)
                    (bit-shift-right b2 4))
         c2 (bit-or (bit-shift-left (bit-and 2r1111 b2) 4)
                    (bit-shift-right b3 2))]
     [c1 c2]))
  ([b1 b2 b3 b4]
   (let [c1 (bit-or (bit-shift-left b1 2)                  ; b1 shifted to make room
                    (bit-shift-right b2 4))                ; first 2 bits of b2
         c2 (bit-or (bit-shift-left (bit-and 2r1111 b2) 4) ; last 4 bits of b2
                    (bit-shift-right b3 2))                ; first 4 bits of b3
         c3 (bit-or (bit-shift-left (bit-and 2r11 b3) 6)   ; last 4 bits of b3
                    b4)]                                   ; b4
     [c1 c2 c3])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(t/deftest test-base64-reduce-bytes
  (t/is (= (apply base64-reduce-bytes [2r00010011 2r00010110 2r00000101 2r00101110])
         [2r01001101 2r01100001 2r01101110])))</pre></td></tr><tr><td class="docs"><p>Decode a base64 encoded string (or bytestream)</p>
</td><td class="codes"><pre class="brush: clojure">(defn base64-decode
  [str]
  (let [chars     (map char str)
        sanitized (filter (partial contains? base64-chars) chars)
        indices   (map (map-invert base64-map) sanitized)
        quads     (partition 4 4 [] (map byte indices))
        triples   (map (partial apply base64-reduce-bytes) quads)]
    (flatten triples)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(t/deftest test-base64-decode-long
  (t/is (= (str &quot;49276d206b696c6c696e6720796f757220627261696e206c&quot;
                &quot;696b65206120706f69736f6e6f7573206d757368726f6f6d&quot;)
           (utils/bytes-to-hex
            (base64-decode
             &quot;SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t&quot;)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def base64-to-str (comp utils/bytes-to-str base64-decode))</pre></td></tr><tr><td class="docs"><p>Test vectors from <a href="https://tools.ietf.org/html/rfc4648#section-10">RFC4648</a></p>
</td><td class="codes"><pre class="brush: clojure">(t/deftest test-base64-decode
  (t/is (=        (base64-to-str )))
  (t/is (= &quot;f&quot;      (base64-to-str &quot;Zg==&quot;)))
  (t/is (= &quot;fo&quot;     (base64-to-str &quot;Zm8=&quot;)))
  (t/is (= &quot;foo&quot;    (base64-to-str &quot;Zm9v&quot;)))
  (t/is (= &quot;fooba&quot;  (base64-to-str &quot;Zm9vYmE=&quot;)))
  (t/is (= &quot;foobar&quot; (base64-to-str &quot;Zm9vYmFy&quot;)))
  (t/is (= &quot;foob&quot;   (base64-to-str &quot;Zm9vYg==&quot;))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#hale.cryptopals.set1.challenge2" name="hale.cryptopals.set1.challenge2"><h1 class="project-name">hale.cryptopals.set1.challenge2</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><h1>Fixed XOR</h1>

<p>Write a function that takes two equal-length buffers and produces their XOR
combination.</p>

<p>If your function works properly, then when you feed it the string:</p>

<pre><code>1c0111001f010100061a024b53535009181c
</code></pre>

<p>... after hex decoding, and when XOR'd against:</p>

<pre><code>686974207468652062756c6c277320657965
</code></pre>

<p>... should produce:</p>

<pre><code>746865206b696420646f6e277420706c6179
</code></pre>

<hr />
</td><td class="codes"><pre class="brush: clojure">(ns hale.cryptopals.set1.challenge2
  (:require [hale.cryptopals.utils :as utils]
            [clojure.test :as t]
            [clojure.string :as str]))</pre></td></tr><tr><td class="docs"><p>XORs two equal length bytestreams</p>
</td><td class="codes"><pre class="brush: clojure">(defn xor-combine
  [h1 h2]
  (let [b1    (utils/hex-to-bytes h1)
        b2    (utils/hex-to-bytes h2)
        xored (map bit-xor b1 b2)
        hexes (map (partial format &quot;%x&quot;) xored)]
    (apply str hexes)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(t/deftest test-xor-combine
  (t/is (= (xor-combine &quot;1c0111001f010100061a024b53535009181c&quot;
                      &quot;686974207468652062756c6c277320657965&quot;)
         &quot;746865206b696420646f6e277420706c6179&quot;)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#hale.cryptopals.set1.challenge3" name="hale.cryptopals.set1.challenge3"><h1 class="project-name">hale.cryptopals.set1.challenge3</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><h1>Single-byte XOR cipher</h1>

<p>The hex encoded string:</p>

<pre><code>1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736
</code></pre>

<p>...has been XOR'd against a single character. Find the key, decrypt the message.</p>

<p>You can do this by hand. But don't: write code to do it for you.</p>

<p>How? Devise some method for "scoring" a piece of English plaintext. Character
frequency is a good metric. Evaluate each output and choose the one with the
best score.</p>

<hr />
</td><td class="codes"><pre class="brush: clojure">(ns hale.cryptopals.set1.challenge3
  (:require [clojure.test :as t]
            [clojure.string :as str]
            [clojure.set :refer [difference]]
            [hale.cryptopals.utils :as utils]
            [hale.cryptopals.set1.challenge1 :as base64]))</pre></td></tr><tr><td class="docs"><p>DEPRECATED: Measures 'englishness' of a string by the absence of 'weird' chars</p>

<p>I completed this challenge initially by measuring the simple quantity of
weird characters in the output. I had the Base64 vals already to hand, so
used that as by definition of normalcy.</p>
</td><td class="codes"><pre class="brush: clojure">(defn str-englishness-weirdness
  [str]
  (let [eng-chars       (vals base64/base64-map)
        str-chars       (seq (char-array str))
        non-eng-chars   (difference (set eng-chars) (set str-chars))
        p-non-eng-chars (/ (count non-eng-chars) (count (eng-chars)))]
    (- 1 p-non-eng-chars)))</pre></td></tr><tr><td class="docs"><p>...this doesn't work very well. Sentences containing spaces in particular are
penalized, whereas jumbmles of ASCII are considered all equally English. Back
to the drawing board (what was that they said about frequencies...?)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>DEPRECATED: Measures 'englishness' of a string by propotion of word chars</p>

<p>Still ignoring the advice about frequencies, I wrote this which looks at the
proportion of word characters (this time including space!). This was good
enough to pass Challenge 3.</p>
</td><td class="codes"><pre class="brush: clojure">(defn str-englishness-words
  [str]
  (let [eng-chars (count (re-seq #&quot;[a-zA-Z ]&quot; str))]
    (/ eng-chars (count str))))</pre></td></tr><tr><td class="docs"><h2>Frequencies!</h2>

<p>After a bit of research, I stumbled across the <strong>Chi-squared</strong> test as a way
of measuring a set of observations against expected outcomes.</p>

<p>The test takes two sets of observations (actual and expected), and reduces
the differences between them to a single number.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn chi-square [expected actual]
  (/ (utils/square (- actual expected)) expected))</pre></td></tr><tr><td class="docs"><p>Reduces the difference between two sets of observations to a single number.
  Lower numbers indicate greater convergence.</p>

<p>Note that this takes a third argument for the 'default' value if nothing was
observed. This is not actually supported by the underlying statistic. In
fact, the test is unreliable when the number of observations is less than
five. However, it works for our purposes if we assign a default small value
for missing occurrences.</p>
</td><td class="codes"><pre class="brush: clojure">(defn chi-square-distance
  ([e-freqs a-freqs] (chi-square-distance e-freqs a-freqs 0.000001))
  ([e-freqs a-freqs missing]
  (let [distances (map (fn [[a-key a-val]] (chi-square (get e-freqs a-key missing) a-val)) a-freqs)]
    (reduce + distances))))</pre></td></tr><tr><td class="docs"><p>Clojure has a built in <code>frequencies</code> function, which we can use to turn the
string under test into a map of actual character observations.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Measures the similarity between a string and a target corpus of string. 'Does
  the string 'fit in' with the other strings?</p>
</td><td class="codes"><pre class="brush: clojure">(defn chi-sq-str-fit
  [rel-freq str]
  (let [chars   (char-array (str/lower-case str))
        e-freqs (utils/map-vals (partial * (count chars)) rel-freq)
        a-freqs (frequencies chars)]
    (* -1 (chi-square-distance e-freqs a-freqs))))</pre></td></tr><tr><td class="docs"><p>Relative character frequencies in the English language are well known. Here
is one such map from Wikipedia:</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Source: <a href="https://en.wikipedia.org/wiki/Letter_frequency#Relative_frequencies_of_letters_in_the_English_language">Wikipedia/Letter_frequency</a></p>
</td><td class="codes"><pre class="brush: clojure">(def eng-char-rel-freq
  { \a 0.08167 \b 0.01492 \c 0.02782 \d 0.04253
   \e 0.12702 \f 0.02228 \g 0.02015 \h 0.06094
   \i 0.06966 \j 0.00153 \k 0.00772 \l 0.04025
   \m 0.02406 \n 0.06749 \o 0.07507 \p 0.01929
   \q 0.00095 \r 0.05987 \s 0.06327 \t 0.09056
   \u 0.02758 \v 0.00978 \w 0.02360 \x 0.00150
   \y 0.01974 \z 0.00074 })</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def str-englishness (partial chi-sq-str-fit eng-char-rel-freq))</pre></td></tr><tr><td class="docs"><p>There is one problem with the above approach: it ignores punctiation. It
turns out the plaintext of many of these solutions contains lots of spaces,
enough that when it was reused in later challenges the wrong result was
sometimes returned.</p>

<p>How can we include <code>\space</code> and other commmon chars in the frequency map?</p>

<p>We could juggle the numbers or find another map that includes punctuation,
but I thought it would be fun to produce my own, since we have this handy
<code>frequencies</code> function:</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Reads text files in data/training-text returning a single string with every
  file concatonated. _This project is not distributed with any training data;
  please supply your own by pasting text files in data/training-text_</p>
</td><td class="codes"><pre class="brush: clojure">(def training-text
  (let [contents  (file-seq (clojure.java.io/file &quot;./data/training-text&quot;))
        filenames (filter #(.isFile %) contents)]
    (str/join (map slurp filenames))))</pre></td></tr><tr><td class="docs"><p>Given some text and some allowed characters from that text, returns a map of
  the relative frequency of each character.</p>
</td><td class="codes"><pre class="brush: clojure">(defn custom-char-rel-freq
  ([text] (custom-char-rel-freq text #&quot;[a-z ']&quot;))
  ([text regex]
   (let [sanitized (str/lower-case text)
         chars     (map #(char (first %)) (re-seq regex sanitized))
         freqs     (frequencies chars)
         rel-freqs (utils/map-vals (fn [v] (/ v (count chars))) freqs)]
     rel-freqs)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def trained-char-rel-freq (custom-char-rel-freq training-text))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def str-fitness (partial chi-sq-str-fit trained-char-rel-freq))</pre></td></tr><tr><td class="docs"><p>What shall we use for training data? Well given this quote:</p>

<blockquote>
  <p>An appreciation for early-90's MTV hip-hop can't hurt either.</p>
</blockquote>

<p>...let's create a frequency map of Vanilla Ice lyrics. The results are as
follows:</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Expected relative frequencies of each letter in a Vanilla Ice lyric</p>
</td><td class="codes"><pre class="brush: clojure">(def vanilla-ice-rel-freq
  { \a 0.06212 \b 0.01350 \c 0.02465 \d 0.02556
    \e 0.08375 \f 0.01177 \g 0.01883 \h 0.03980
    \i 0.06460 \j 0.00380 \k 0.01630 \l 0.03510
    \m 0.02448 \n 0.05429 \o 0.07037 \p 0.01495
    \q 0.00032 \r 0.03612 \s 0.04152 \t 0.07494
    \u 0.02708 \v 0.00732 \w 0.01795 \x 0.00162
    \y 0.02644 \z 0.00150 \' 0.01737 \space 0.18394 })</pre></td></tr><tr><td class="docs"><p>Measures the likelyhood of a string being a Vanilla Ice lyric, using a
  chi-squared test against a relative character frequency map trained on
  lyrics.</p>
</td><td class="codes"><pre class="brush: clojure">(def str-iciness
  (partial chi-sq-str-fit vanilla-ice-rel-freq))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(t/deftest test-str-iciness
  (let [icy &quot;Now that the party is jumping\n&quot;
        eng &quot;I have of late, but wherefore I know not, lost all my mirth&quot;]
    (t/is (&gt; (str-iciness icy) (str-iciness eng)))))</pre></td></tr><tr><td class="docs"><p>XORs a bytestream against the given char</p>
</td><td class="codes"><pre class="brush: clojure">(defn single-char-xor
  [bytestream char]
  (let [b1 bytestream
        b2 (map byte (repeat char))]
    (map bit-xor b1 b2)))</pre></td></tr><tr><td class="docs"><p>XOR the bytstream against the char then evaluate its fitness</p>
</td><td class="codes"><pre class="brush: clojure">(defn xor-with-score
  ([bytestream char] (xor-with-score bytestream char str-iciness))
  ([bytestream char fitness-fn]
  (let [xored (single-char-xor bytestream char)]
    {:in bytestream
     :out xored
     :char char
     :score (fitness-fn (utils/bytes-to-str xored))})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn decode-single-char-xor
  [bytestream]
  (let [candidates (map (partial xor-with-score bytestream) utils/printable-ascii-chars)
        sorted     (sort-by :score candidates)
        winner     (last sorted)]
    winner))</pre></td></tr><tr><td class="docs"><p>Single-byte XOR cipher</p>
</td><td class="codes"><pre class="brush: clojure">(defn decode-single-char-xor-encoded-hex-str
  [str]
  (let [bytes  (utils/hex-to-bytes str)
        winner (decode-single-char-xor bytes)]
    (-&gt; winner
        (update :out utils/bytes-to-str)
        (assoc :in str))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(t/deftest test-decode-single-char-xor-encoded-hex-str
  (let [hex-str &quot;1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736&quot;
        result  (decode-single-char-xor-encoded-hex-str hex-str)]
    (t/is (= (:out result) &quot;Cooking MC's like a pound of bacon&quot;))
    (t/is (= (:char result) \X))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#hale.cryptopals.set1.challenge4" name="hale.cryptopals.set1.challenge4"><h1 class="project-name">hale.cryptopals.set1.challenge4</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><h1>Detect single-character XOR</h1>

<p>One of the 60 character strings in this file has been encrypted by
single-character XOR. Find it.</p>

<p>(Your code from #3 should help.)</p>

<hr />
</td><td class="codes"><pre class="brush: clojure">(ns hale.cryptopals.set1.challenge4
  (:require [hale.cryptopals.set1.challenge3 :as challenge3]
            [clojure.test :as t]
            [clojure.string :as str]))</pre></td></tr><tr><td class="docs"><p>From a seq of hex strings, finds and decodes the one which has been encrypted
  by single-character XOR</p>
</td><td class="codes"><pre class="brush: clojure">(defn detect-single-char-xor
  [strings]
  (last (sort-by :score (map challenge3/decode-single-char-xor-encoded-hex-str strings))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(t/deftest test-detect-single-char-xor
  (let [strings (str/split (slurp &quot;data/s1c4.txt&quot;) #&quot;\s&quot;)
        result  (detect-single-char-xor strings)]
    (t/is (= (:in result) &quot;7b5a4215415d544115415d5015455447414c155c46155f4058455c5b523f&quot;))
    (t/is (= (:out result) &quot;Now that the party is jumping\n&quot;))
    (t/is (= (:char result) \5))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#hale.cryptopals.set1.challenge5" name="hale.cryptopals.set1.challenge5"><h1 class="project-name">hale.cryptopals.set1.challenge5</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><h1>Implement repeating-key XOR</h1>

<p>Here is the opening stanza of an important work of the English language:</p>

<pre><code>Burning 'em, if you ain't quick and nimble
I go crazy when I hear a cymbal
</code></pre>

<p>Encrypt it, under the key "ICE", using repeating-key XOR.</p>

<p>In repeating-key XOR, you'll sequentially apply each byte of the key; the
first byte of plaintext will be XOR'd against I, the next C, the next E, then
I again for the 4th byte, and so on.</p>

<p>It should come out to:</p>

<pre><code>0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272
a282b2f20430a652e2c652a3124333a653e2b2027630c692b20283165286326302e27282f
</code></pre>

<p>Encrypt a bunch of stuff using your repeating-key XOR function. Encrypt your
mail. Encrypt your password file. Your .sig file. Get a feel for it. I
promise, we aren't wasting your time with this.</p>

<hr />
</td><td class="codes"><pre class="brush: clojure">(ns hale.cryptopals.set1.challenge5
  (:require [clojure.test :as t]
            [hale.cryptopals.utils :as utils]))</pre></td></tr><tr><td class="docs"><p>XOR-encode an input string using the given key</p>
</td><td class="codes"><pre class="brush: clojure">(defn repeating-key-xor
  [key str]
  (let [b1    (utils/str-to-bytes str)
        b2    (flatten (repeat (map byte (char-array key))))
        xored (map bit-xor b1 b2)]
    (utils/bytes-to-hex xored)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(t/deftest test-repeating-key-xor
  (let [input &quot;Burning 'em, if you ain't quick and nimble\nI go crazy when I hear a cymbal&quot;
        key   &quot;ICE&quot;
        result (repeating-key-xor key input)]
    (t/is (= result
             (str &quot;0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a262263&quot;
                  &quot;24272765272a282b2f20430a652e2c652a3124333a653e2b2027630c692b2028&quot;
                  &quot;3165286326302e27282f&quot;)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#hale.cryptopals.set1.challenge6" name="hale.cryptopals.set1.challenge6"><h1 class="project-name">hale.cryptopals.set1.challenge6</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><h1>Break repeating-key XOR</h1>

<p><strong>It is officially on, now.</strong> This challenge isn't conceptually hard, but it
involves actual error-prone coding. The other challenges in this set are
there to bring you up to speed. This one is there to qualify you. If you can
do this one, you're probably just fine up to Set 6.</p>

<p>There's a file here. It's been base64'd after being encrypted with repeating-key XOR.</p>

<p>Decrypt it.</p>

<p>Here's how:</p>

<ol>
<li>Let KEYSIZE be the guessed length of the key; try values from 2 to (say)
40.</li>
<li>Write a function to compute the edit distance/Hamming distance between two
strings. The Hamming distance is just the number of differing bits. The
distance between <code>this is a test</code> and <code>wokka wokka!!!</code> is 37. Make sure
your code agrees before you proceed.</li>
<li>For each KEYSIZE, take the first KEYSIZE worth of bytes, and the second
KEYSIZE worth of bytes, and find the edit distance between them. Normalize
this result by dividing by KEYSIZE.</li>
<li>The KEYSIZE with the smallest normalized edit distance is probably the
key. You could proceed perhaps with the smallest 2-3 KEYSIZE values. Or
take 4 KEYSIZE blocks instead of 2 and average the distances.</li>
<li>Now that you probably know the KEYSIZE: break the ciphertext into blocks
of KEYSIZE length.</li>
<li>Now transpose the blocks: make a block that is the first byte of every
block, and a block that is the second byte of every block, and so on.</li>
<li>Solve each block as if it was single-character XOR. You already have code
to do this.</li>
<li>For each block, the single-byte XOR key that produces the best looking
histogram is the repeating-key XOR key byte for that block. Put them together
and you have the key.</li>
</ol>

<p>This code is going to turn out to be surprisingly useful later on. Breaking
repeating-key XOR ("Vigenere") statistically is obviously an academic
exercise, a "Crypto 101" thing. But more people "know how" to break it than
can actually break it, and a similar technique breaks something much more
important.</p>

<hr />
</td><td class="codes"><pre class="brush: clojure">(ns hale.cryptopals.set1.challenge6
  (:require [clojure.test :as t]
            [clojure.string :as str]
            [hale.cryptopals.utils :as utils]
            [hale.cryptopals.set1.challenge1 :as base64]
            [hale.cryptopals.set1.challenge3 :as challenge3]))</pre></td></tr><tr><td class="docs"><p><strong>1. 2. 3. 4. Find the key size</strong></p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- edit-distance-bytes
  [b1 b2]
  (let [xored      (map bit-xor b1 b2)
        bit-counts (map #(Integer/bitCount %) xored)]
    (reduce + bit-counts)))</pre></td></tr><tr><td class="docs"><p>Calculate the edit distance (number of differing bits) between two strings</p>
</td><td class="codes"><pre class="brush: clojure">(defn edit-distance
  [s1 s2]
  (let [b1 (utils/str-to-bytes s1)
        b2 (utils/str-to-bytes s2)]
    (edit-distance-bytes b1 b2)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(t/deftest test-edit-distance
  (t/is (= (edit-distance &quot;this is a test&quot; &quot;wokka wokka!!!&quot;) 37)))</pre></td></tr><tr><td class="docs"><p>Score a given keysize based on the hamming-distance of its application against the bytestream</p>
</td><td class="codes"><pre class="brush: clojure">(defn evaluate-key-size
  [bytes ks]
  (let [byte-pairs (partition 2 (partition ks bytes))
        scores     (flatten (map #(apply edit-distance-bytes %) byte-pairs))
        avg-score  (/ (apply + scores) (count scores))
        normalized (/ avg-score ks)]
    {:score normalized :ks ks}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn determine-key-size
  [bytes n]
  (let [candidates (range 2 n)
        scores (map #(evaluate-key-size bytes %) candidates)]
    (apply min-key :score scores)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(t/deftest test-determine-key-size
  (t/is (= 29 (:ks (determine-key-size (base64/base64-decode (slurp &quot;data/s1c6.txt&quot;)) 50)))))</pre></td></tr><tr><td class="docs"><p><strong>5. 6. 7. 8. Find the key</strong></p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn transpose [m] (apply mapv vector m))</pre></td></tr><tr><td class="docs"><p>Given bytes encrypted with repeating-key XOR, find the key</p>
</td><td class="codes"><pre class="brush: clojure">(defn find-repeating-xor-key
  [bs]
  (let [keysize   (:ks (determine-key-size bs 50))
        ;; _ (println (str &quot;best guess key size is &quot; keysize &quot; (tried up to 50)&quot;))
        blocks    (transpose (partition keysize bs))
        decrypted (map (partial challenge3/decode-single-char-xor) blocks)]
    (apply str (map :char decrypted))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(t/deftest test-find-repeating-xor-key
  (t/is (= &quot;Terminator X: Bring the noise&quot;
         (find-repeating-xor-key (base64/base64-decode (slurp &quot;data/s1c6.txt&quot;))))))</pre></td></tr><tr><td class="docs"><p>Decodes input bytestream by guessing the key.</p>
</td><td class="codes"><pre class="brush: clojure">(defn decrypt-repeating-key-xor
  [bs1]
  (let [key   (find-repeating-xor-key bs1)
        bs2   (flatten (repeat (map byte (char-array key))))
        xored (map bit-xor bs1 bs2)]
    (utils/bytes-to-str xored)))</pre></td></tr><tr><td class="docs"><p>Break repeating-key XOR</p>
</td><td class="codes"><pre class="brush: clojure">(def decrypt-repeating-key-xor-base64
  (comp decrypt-repeating-key-xor base64/base64-decode))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(t/deftest test-decrypt-repeating-key-xor
  (t/is (= (decrypt-repeating-key-xor-base64 (slurp &quot;data/s1c6.txt&quot;))
           (slurp &quot;data/s1c6.solution.txt&quot;))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#hale.cryptopals.set1.challenge7" name="hale.cryptopals.set1.challenge7"><h1 class="project-name">hale.cryptopals.set1.challenge7</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><h1>AES in ECB mode</h1>

<p>The Base64-encoded content in this file has been encrypted via AES-128 in ECB
mode under the key:</p>

<pre><code>"YELLOW SUBMARINE".
</code></pre>

<p>(case-sensitive, without the quotes; exactly 16 characters; I like "YELLOW
SUBMARINE" because it's exactly 16 bytes long, and now you do too).</p>

<p>Decrypt it. You know the key, after all.</p>

<p>Easiest way: use OpenSSL::Cipher and give it AES-128-ECB as the cipher.</p>

<p><em>Do this with code.</em> You can obviously decrypt this using the OpenSSL
command-line tool, but we're having you get ECB working in code for a reason.
You'll need it a lot later on, and not just for attacking ECB.</p>

<hr />
</td><td class="codes"><pre class="brush: clojure">(ns hale.cryptopals.set1.challenge7
  (:require [hale.cryptopals.utils :as utils]
            [hale.cryptopals.set1.challenge1 :as base64]
            [clojure.test :as t])
  (:import [javax.crypto Cipher]
           [javax.crypto.spec SecretKeySpec]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn decrypt-aes-ecb
  [byte-stream key]
  (let [key-spec  (SecretKeySpec. (.getBytes key) &quot;AES&quot;)
        cipher    (Cipher/getInstance &quot;AES/ECB/PKCS5Padding&quot;)
        _         (.init cipher (int Cipher/DECRYPT_MODE) key-spec)
        decrypted (.doFinal cipher (byte-array byte-stream))]
    decrypted))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn decrypt-aes-ecb-base64 [b64 key]
  (decrypt-aes-ecb (base64/base64-decode b64) key))</pre></td></tr><tr><td class="docs"><p>Decrypt AES in ECB mode</p>
</td><td class="codes"><pre class="brush: clojure">(def decrypt-aes-ecb-base64-to-str
  (comp utils/bytes-to-str decrypt-aes-ecb-base64))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(t/deftest decrypt-aes-in-ecb-mode
  (let [key &quot;YELLOW SUBMARINE&quot;
        ciphertext (slurp &quot;data/s1c7.txt&quot;)
        plaintext (slurp &quot;data/s1c7.solution.txt&quot;)]
    (t/is (= (decrypt-aes-ecb-base64-to-str ciphertext key) plaintext))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#hale.cryptopals.set1.challenge8" name="hale.cryptopals.set1.challenge8"><h1 class="project-name">hale.cryptopals.set1.challenge8</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><h1>Detect AES in ECB mode.</h1>

<p>In this file are a bunch of hex-encoded ciphertexts. One of them has been
encrypted with ECB. Detect it.</p>

<p>Remember that the problem with ECB is that it is stateless and deterministic;
the same 16 byte plaintext block will always produce the same 16 byte
ciphertext.</p>

<hr />
</td><td class="codes"><pre class="brush: clojure">(ns hale.cryptopals.set1.challenge8
  (:require [hale.cryptopals.set1.challenge3 :refer [chi-square-distance]]
            [hale.cryptopals.utils :as utils]
            [clojure.string :as str]
            [clojure.test :as t]))</pre></td></tr><tr><td class="docs"><p>Cyphertext known to be encoded with AES in ECB mode will exhibit repeating
blocks of bytes (if the plaintext has any repetition). A good heuristic for
AES in ECB mode would therefore be 'contains repetition'.</p>

<p>Info about the source data:</p>

<ol>
<li>64 strings to test</li>
<li>Each string is 60 chars long (hex encoded, so that's 30 bytes)</li>
</ol>

<p>We already have that chi-squared function which can measure the deviation of
observations from what is expected.</p>

<p>The opposite of repetition is randomness. Randomness can be defined here as
'each byte is equaly likey to appear'. I.e. the bytes should be uniformally
distributed. The least-random ciphertext will therefore be the set of bytes
that is most deviant from the uniform distribution (where every outcome is
equally likely).</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Standard uniform distribution for a set of bytes</p>
</td><td class="codes"><pre class="brush: clojure">(def uniform-bytes-rel-freq-map
  (zipmap (map byte (range 0 128))
          (repeat 128 (/ 1 128))))</pre></td></tr><tr><td class="docs"><p><strong>Set 1 :: Challenge 8 :: Detect AES in ECB mode</strong></p>
</td><td class="codes"><pre class="brush: clojure">(defn detect-aes-in-ecb-mode
  [strs]
  (let [streams (map utils/hex-to-bytes strs)
        e-freqs (utils/map-vals (partial * 30) uniform-bytes-rel-freq-map)
        score   (fn [bs] (chi-square-distance e-freqs (frequencies bs) (/ 1 256)))
        scores  (map #(hash-map :in % :score (score %)) streams)
        winner  (apply max-key :score scores)]
    (utils/bytes-to-hex (:in winner))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(t/deftest test-detect-aes-in-ecb-mode
  (let [strs (str/split (slurp &quot;data/s1c8.txt&quot;) #&quot;\n&quot;)
        expected (nth strs 132)
        actual (detect-aes-in-ecb-mode strs)]
    (t/is (= expected actual))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#hale.cryptopals.set2" name="hale.cryptopals.set2"><h1 class="project-name">hale.cryptopals.set2</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><h1>Crypto Challenge Set 2</h1>

<p>This is the first of several sets on block cipher cryptography. This is
bread-and-butter crypto, the kind you'll see implemented in most web software
that does crypto.</p>

<p>This set is relatively easy. People that clear set 1 tend to clear set 2
somewhat quickly.</p>

<p>Three of the challenges in this set are extremely valuable in breaking
real-world crypto; one allows you to decrypt messages encrypted in the
default mode of AES, and the other two allow you to rewrite messages
encrypted in the most popular modes of AES.</p>
</td><td class="codes"><pre class="brush: clojure">(ns hale.cryptopals.set2)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#hale.cryptopals.set2.challenge9" name="hale.cryptopals.set2.challenge9"><h1 class="project-name">hale.cryptopals.set2.challenge9</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><h1>Implement PKCS#7 padding</h1>

<p>A block cipher transforms a fixed-sized block (usually 8 or 16 bytes) of
plaintext into ciphertext. But we almost never want to transform a single
block; we encrypt irregularly-sized messages.</p>

<p>One way we account for irregularly-sized messages is by padding, creating a
plaintext that is an even multiple of the blocksize. The most popular padding
scheme is called PKCS#7.</p>

<p>So: pad any block to a specific block length, by appending the number of
bytes of padding to the end of the block. For instance,</p>

<pre><code>"YELLOW SUBMARINE"
</code></pre>

<p>... padded to 20 bytes would be:</p>

<pre><code>"YELLOW SUBMARINE\x04\x04\x04\x04"
</code></pre>

<hr />
</td><td class="codes"><pre class="brush: clojure">(ns hale.cryptopals.set2.challenge9
  (:require [clojure.test :as t]
            [hale.cryptopals.utils :as utils]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn pad-block
  ([block] (pad-block block 16 0x04))
  ([block blocksize] (pad-block block blocksize 0x04))
  ([block blocksize pad]
  (let [pad-length (- blocksize (count block))]
    (flatten (conj (vec block) (repeat pad-length pad))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(t/deftest test-pad-block
  (t/is (= (map char [\Y \E \L \L \O \W \space \S \U \B
                       \M \A \R \I \N \E 0x04 0x04 0x04 0x04])
           (map char (pad-block (utils/str-to-bytes &quot;YELLOW SUBMARINE&quot;) 20)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#hale.cryptopals.utils" name="hale.cryptopals.utils"><h1 class="project-name">hale.cryptopals.utils</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns hale.cryptopals.utils
  (:require [clojure.test :as t]
            [clojure.string :as str]))</pre></td></tr><tr><td class="docs"><p>FIXME: UNSAFE -- interprets string as hex using read-string</p>
</td><td class="codes"><pre class="brush: clojure">(defn hex-to-bytes
  [hex] (let [chars (partition 2 hex)
              parse-chars (fn [[c1 c2]] (read-string (str &quot;0x&quot; c1 c2)))]
          (map parse-chars chars)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(t/deftest test-hex-to-bytes
  (t/is (= (hex-to-bytes &quot;4d616e&quot;)
         (map byte [0x4d 0x61 0x6e])
         (map byte [77 97 110])
         (map byte [2r1001101 2r1100001 2r1101110]))))</pre></td></tr><tr><td class="docs"><p>Given a list of bytes, return a string representation of those bytes in
  binary form (ones-and-zeros)</p>
</td><td class="codes"><pre class="brush: clojure">(defn print-bytes
  [byte &amp; rest]
  (let [stringify (fn [b]      (Integer/toBinaryString b))
        pad       (fn [string] (format &quot;%8s&quot; string))
        zero-pad  (fn [string] (str/replace string &quot; &quot; &quot;0&quot;))]
    (map (comp zero-pad pad stringify) (conj rest byte))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(t/deftest test-print-bytes
  (t/is (= (apply print-bytes (hex-to-bytes &quot;4d616e&quot;))
         [&quot;01001101&quot; &quot;01100001&quot; &quot;01101110&quot;])))</pre></td></tr><tr><td class="docs"><p>Also known as 'unhexify'</p>
</td><td class="codes"><pre class="brush: clojure">(defn hex-to-str
  [hex]
  (let [bytes (hex-to-bytes hex)
        chars (map char bytes)]
    (apply str chars)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn bytes-to-str [bytes] (apply str (map char bytes)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn map-vals [f m]
  (into {} (for [[k v] m] [k (f v)])))</pre></td></tr><tr><td class="docs"><p>Source: https://en.wikipedia.org/wiki/ASCII#Printable_characters</p>
</td><td class="codes"><pre class="brush: clojure">(def printable-ascii-chars
  (map char (range 32 127)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn square [x] (* x x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn str-to-bytes
  [str]
  (let [chars (map char str)]
    (map byte chars)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn bytes-to-hex
  [bytes]
  (apply str (map (partial format &quot;%02x&quot;) bytes)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr></table><div class="footer">Generated by <a href="https://github.com/gdeer81/marginalia">Marginalia</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a><div id="floating-toc"><ul><li class="floating-toc-li" id="floating-toc_hale.cryptopals.set1">hale.cryptopals.set1</li><li class="floating-toc-li" id="floating-toc_hale.cryptopals.set1.challenge1">hale.cryptopals.set1.challenge1</li><li class="floating-toc-li" id="floating-toc_hale.cryptopals.set1.challenge2">hale.cryptopals.set1.challenge2</li><li class="floating-toc-li" id="floating-toc_hale.cryptopals.set1.challenge3">hale.cryptopals.set1.challenge3</li><li class="floating-toc-li" id="floating-toc_hale.cryptopals.set1.challenge4">hale.cryptopals.set1.challenge4</li><li class="floating-toc-li" id="floating-toc_hale.cryptopals.set1.challenge5">hale.cryptopals.set1.challenge5</li><li class="floating-toc-li" id="floating-toc_hale.cryptopals.set1.challenge6">hale.cryptopals.set1.challenge6</li><li class="floating-toc-li" id="floating-toc_hale.cryptopals.set1.challenge7">hale.cryptopals.set1.challenge7</li><li class="floating-toc-li" id="floating-toc_hale.cryptopals.set1.challenge8">hale.cryptopals.set1.challenge8</li><li class="floating-toc-li" id="floating-toc_hale.cryptopals.set2">hale.cryptopals.set2</li><li class="floating-toc-li" id="floating-toc_hale.cryptopals.set2.challenge9">hale.cryptopals.set2.challenge9</li><li class="floating-toc-li" id="floating-toc_hale.cryptopals.utils">hale.cryptopals.utils</li></ul></div></div>













































  <script type="text/javascript">
    SyntaxHighlighter.defaults['gutter'] = false;
SyntaxHighlighter.all();
  </script>

  <script type="text/javascript">
// hackity hack
$(document).ready(function() {
    var ft = $("#floating-toc");
    var ul = ft.find('ul');
    var lis = ft.find('li');
    var liHeight = $(lis.first()).height();

    ul.css('margin', '0px');
    ft.css('height', liHeight + 'px');

    showNs = function(ns) {
        var index = 0;

        for(i in nsPositions.nss) {
            if(ns == nsPositions.nss[i]) index = i;
        }

        if(index != lastNsIndex) {
            lastNsIndex = index;
            ul.animate({marginTop: (-1 * liHeight * index) + 'px'},
               300);
        }

    }

    var calcNsPositions = function() {
        var hheight = $('.docs-header').first().height();
        var nss = [];
        var anchors = [];
        var positions = [];
        $.each(lis, function(i, el) {
            var ns = $(el).attr('id').split('_')[1];
            nss.push(ns);
            var a = $("a[name='"+ns+"']");
            anchors.push(a);
            positions.push(a.offset().top - hheight);
            // console.log(a.offset().top)
        });

        return {nss: nss, positions: positions};
    }

    var nsPositions = calcNsPositions();
    // console.log(nsPositions)
    var lastNsIndex = -1;
    var $window = $(window);

    var currentSection = function(nsp) {
        var ps = nsp.positions;
        var scroll = $window.scrollTop();
        var nsIndex = -1;

        for(var i = 0, length = ps.length; i < length; i++) {
            if(ps[i] >= scroll) {
                nsIndex = i-1;
                break;
            }
        }

        if(nsIndex == -1) {
             if(scroll >= ps[0]) {
                 nsIndex = ps.length - 1;
             } else {
                 nsIndex = 0;
             }
        }

        return nsp.nss[nsIndex];
    }

    $(window).scroll(function(e) {
        showNs(currentSection(nsPositions));
    });
});
</script>


